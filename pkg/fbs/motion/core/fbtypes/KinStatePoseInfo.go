// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// Kinematics position information of the currently active command
type KinStatePoseInfoT struct {
	AxisInfo []string `json:"axisInfo"`
	PosCap string `json:"posCap"`
	OriCap string `json:"oriCap"`
	Cos string `json:"cos"`
}

func (t *KinStatePoseInfoT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	axisInfoOffset := flatbuffers.UOffsetT(0)
	if t.AxisInfo != nil {
		axisInfoLength := len(t.AxisInfo)
		axisInfoOffsets := make([]flatbuffers.UOffsetT, axisInfoLength)
		for j := 0; j < axisInfoLength; j++ {
			axisInfoOffsets[j] = builder.CreateString(t.AxisInfo[j])
		}
		KinStatePoseInfoStartAxisInfoVector(builder, axisInfoLength)
		for j := axisInfoLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(axisInfoOffsets[j])
		}
		axisInfoOffset = builder.EndVector(axisInfoLength)
	}
	posCapOffset := flatbuffers.UOffsetT(0)
	if t.PosCap != "" {
		posCapOffset = builder.CreateString(t.PosCap)
	}
	oriCapOffset := flatbuffers.UOffsetT(0)
	if t.OriCap != "" {
		oriCapOffset = builder.CreateString(t.OriCap)
	}
	cosOffset := flatbuffers.UOffsetT(0)
	if t.Cos != "" {
		cosOffset = builder.CreateString(t.Cos)
	}
	KinStatePoseInfoStart(builder)
	KinStatePoseInfoAddAxisInfo(builder, axisInfoOffset)
	KinStatePoseInfoAddPosCap(builder, posCapOffset)
	KinStatePoseInfoAddOriCap(builder, oriCapOffset)
	KinStatePoseInfoAddCos(builder, cosOffset)
	return KinStatePoseInfoEnd(builder)
}

func (rcv *KinStatePoseInfo) UnPackTo(t *KinStatePoseInfoT) {
	axisInfoLength := rcv.AxisInfoLength()
	t.AxisInfo = make([]string, axisInfoLength)
	for j := 0; j < axisInfoLength; j++ {
		t.AxisInfo[j] = string(rcv.AxisInfo(j))
	}
	t.PosCap = string(rcv.PosCap())
	t.OriCap = string(rcv.OriCap())
	t.Cos = string(rcv.Cos())
}

func (rcv *KinStatePoseInfo) UnPack() *KinStatePoseInfoT {
	if rcv == nil { return nil }
	t := &KinStatePoseInfoT{}
	rcv.UnPackTo(t)
	return t
}

type KinStatePoseInfo struct {
	_tab flatbuffers.Table
}

func GetRootAsKinStatePoseInfo(buf []byte, offset flatbuffers.UOffsetT) *KinStatePoseInfo {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KinStatePoseInfo{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsKinStatePoseInfo(buf []byte, offset flatbuffers.UOffsetT) *KinStatePoseInfo {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &KinStatePoseInfo{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *KinStatePoseInfo) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KinStatePoseInfo) Table() flatbuffers.Table {
	return rcv._tab
}

/// Type of the axis in the current position calculation of the kinematics, e.g. TRAFO_MEMBER
func (rcv *KinStatePoseInfo) AxisInfo(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *KinStatePoseInfo) AxisInfoLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// Type of the axis in the current position calculation of the kinematics, e.g. TRAFO_MEMBER
/// Position capability of the active joint transformations, e.g. POS_3D
func (rcv *KinStatePoseInfo) PosCap() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Position capability of the active joint transformations, e.g. POS_3D
/// Orientation capability of the active joint transformations, e.g. ORI_3D
func (rcv *KinStatePoseInfo) OriCap() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Orientation capability of the active joint transformations, e.g. ORI_3D
/// Referring coordinate system, e.g. PCS
func (rcv *KinStatePoseInfo) Cos() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Referring coordinate system, e.g. PCS
func KinStatePoseInfoStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func KinStatePoseInfoAddAxisInfo(builder *flatbuffers.Builder, axisInfo flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(axisInfo), 0)
}
func KinStatePoseInfoStartAxisInfoVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KinStatePoseInfoAddPosCap(builder *flatbuffers.Builder, posCap flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(posCap), 0)
}
func KinStatePoseInfoAddOriCap(builder *flatbuffers.Builder, oriCap flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(oriCap), 0)
}
func KinStatePoseInfoAddCos(builder *flatbuffers.Builder, cos flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(cos), 0)
}
func KinStatePoseInfoEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
