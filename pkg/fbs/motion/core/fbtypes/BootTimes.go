// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// return type of requests of the times of the last booting
type BootTimesT struct {
	Elapsed float64 `json:"elapsed"`
	ElapsedThread float64 `json:"elapsedThread"`
	StartedTimeStamp string `json:"startedTimeStamp"`
	EndedTimeStamp string `json:"endedTimeStamp"`
}

func (t *BootTimesT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	startedTimeStampOffset := flatbuffers.UOffsetT(0)
	if t.StartedTimeStamp != "" {
		startedTimeStampOffset = builder.CreateString(t.StartedTimeStamp)
	}
	endedTimeStampOffset := flatbuffers.UOffsetT(0)
	if t.EndedTimeStamp != "" {
		endedTimeStampOffset = builder.CreateString(t.EndedTimeStamp)
	}
	BootTimesStart(builder)
	BootTimesAddElapsed(builder, t.Elapsed)
	BootTimesAddElapsedThread(builder, t.ElapsedThread)
	BootTimesAddStartedTimeStamp(builder, startedTimeStampOffset)
	BootTimesAddEndedTimeStamp(builder, endedTimeStampOffset)
	return BootTimesEnd(builder)
}

func (rcv *BootTimes) UnPackTo(t *BootTimesT) {
	t.Elapsed = rcv.Elapsed()
	t.ElapsedThread = rcv.ElapsedThread()
	t.StartedTimeStamp = string(rcv.StartedTimeStamp())
	t.EndedTimeStamp = string(rcv.EndedTimeStamp())
}

func (rcv *BootTimes) UnPack() *BootTimesT {
	if rcv == nil { return nil }
	t := &BootTimesT{}
	rcv.UnPackTo(t)
	return t
}

type BootTimes struct {
	_tab flatbuffers.Table
}

func GetRootAsBootTimes(buf []byte, offset flatbuffers.UOffsetT) *BootTimes {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &BootTimes{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsBootTimes(buf []byte, offset flatbuffers.UOffsetT) *BootTimes {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &BootTimes{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *BootTimes) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *BootTimes) Table() flatbuffers.Table {
	return rcv._tab
}

/// Elapsed time of the last booting (only valid after end of booting) in seconds
func (rcv *BootTimes) Elapsed() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Elapsed time of the last booting (only valid after end of booting) in seconds
func (rcv *BootTimes) MutateElapsed(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// Elapsed time of the last booting (only valid after end of booting) in seconds only for the own thead (does not include waiting on other threads)
func (rcv *BootTimes) ElapsedThread() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Elapsed time of the last booting (only valid after end of booting) in seconds only for the own thead (does not include waiting on other threads)
func (rcv *BootTimes) MutateElapsedThread(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Time stamp (string), when the last booting started
func (rcv *BootTimes) StartedTimeStamp() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time stamp (string), when the last booting started
/// Time stamp (string), when the last booting ended
func (rcv *BootTimes) EndedTimeStamp() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Time stamp (string), when the last booting ended
func BootTimesStart(builder *flatbuffers.Builder) {
	builder.StartObject(4)
}
func BootTimesAddElapsed(builder *flatbuffers.Builder, elapsed float64) {
	builder.PrependFloat64Slot(0, elapsed, 0.0)
}
func BootTimesAddElapsedThread(builder *flatbuffers.Builder, elapsedThread float64) {
	builder.PrependFloat64Slot(1, elapsedThread, 0.0)
}
func BootTimesAddStartedTimeStamp(builder *flatbuffers.Builder, startedTimeStamp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(startedTimeStamp), 0)
}
func BootTimesAddEndedTimeStamp(builder *flatbuffers.Builder, endedTimeStamp flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(endedTimeStamp), 0)
}
func BootTimesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
