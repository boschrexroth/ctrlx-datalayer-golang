// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// currently interpolated values
type KinIpoValues struct {
	_tab flatbuffers.Table
}

func GetRootAsKinIpoValues(buf []byte, offset flatbuffers.UOffsetT) *KinIpoValues {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &KinIpoValues{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsKinIpoValues(buf []byte, offset flatbuffers.UOffsetT) *KinIpoValues {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &KinIpoValues{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *KinIpoValues) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *KinIpoValues) Table() flatbuffers.Table {
	return rcv._tab
}

/// currently interpolated position
func (rcv *KinIpoValues) IpoPos(j int) float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetFloat64(a + flatbuffers.UOffsetT(j*8))
	}
	return 0
}

func (rcv *KinIpoValues) IpoPosLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// currently interpolated position
func (rcv *KinIpoValues) MutateIpoPos(j int, n float64) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateFloat64(a+flatbuffers.UOffsetT(j*8), n)
	}
	return false
}

/// currently interpolated velocity
func (rcv *KinIpoValues) IpoVel() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// currently interpolated velocity
func (rcv *KinIpoValues) MutateIpoVel(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// currently interpolated acceleration
func (rcv *KinIpoValues) IpoAcc() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// currently interpolated acceleration
func (rcv *KinIpoValues) MutateIpoAcc(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// currently interpolated jerk
func (rcv *KinIpoValues) IpoJrk() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// currently interpolated jerk
func (rcv *KinIpoValues) MutateIpoJrk(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// units of the currently interpolated position
func (rcv *KinIpoValues) IpoPosUnits(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *KinIpoValues) IpoPosUnitsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// units of the currently interpolated position
/// unit of the currently interpolated velocity
func (rcv *KinIpoValues) IpoVelUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the currently interpolated velocity
/// unit of the currently interpolated acceleration
func (rcv *KinIpoValues) IpoAccUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the currently interpolated acceleration
/// unit of the currently interpolated jerk
func (rcv *KinIpoValues) IpoJrkUnits() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the currently interpolated jerk
func KinIpoValuesStart(builder *flatbuffers.Builder) {
	builder.StartObject(8)
}
func KinIpoValuesAddIpoPos(builder *flatbuffers.Builder, ipoPos flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(ipoPos), 0)
}
func KinIpoValuesStartIpoPosVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 8)
}
func KinIpoValuesAddIpoVel(builder *flatbuffers.Builder, ipoVel float64) {
	builder.PrependFloat64Slot(1, ipoVel, 0.0)
}
func KinIpoValuesAddIpoAcc(builder *flatbuffers.Builder, ipoAcc float64) {
	builder.PrependFloat64Slot(2, ipoAcc, 0.0)
}
func KinIpoValuesAddIpoJrk(builder *flatbuffers.Builder, ipoJrk float64) {
	builder.PrependFloat64Slot(3, ipoJrk, 0.0)
}
func KinIpoValuesAddIpoPosUnits(builder *flatbuffers.Builder, ipoPosUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(ipoPosUnits), 0)
}
func KinIpoValuesStartIpoPosUnitsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func KinIpoValuesAddIpoVelUnits(builder *flatbuffers.Builder, ipoVelUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(ipoVelUnits), 0)
}
func KinIpoValuesAddIpoAccUnits(builder *flatbuffers.Builder, ipoAccUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(ipoAccUnits), 0)
}
func KinIpoValuesAddIpoJrkUnits(builder *flatbuffers.Builder, ipoJrkUnits flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(ipoJrkUnits), 0)
}
func KinIpoValuesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
