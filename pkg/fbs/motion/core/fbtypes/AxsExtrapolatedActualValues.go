// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// extrapolated actual values from the drives
type AxsExtrapolatedActualValuesT struct {
	ActualPos float64 `json:"actualPos"`
	ActualVel float64 `json:"actualVel"`
	ActualAcc float64 `json:"actualAcc"`
	ActualPosUnit string `json:"actualPosUnit"`
	ActualVelUnit string `json:"actualVelUnit"`
	ActualAccUnit string `json:"actualAccUnit"`
}

func (t *AxsExtrapolatedActualValuesT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	actualPosUnitOffset := flatbuffers.UOffsetT(0)
	if t.ActualPosUnit != "" {
		actualPosUnitOffset = builder.CreateString(t.ActualPosUnit)
	}
	actualVelUnitOffset := flatbuffers.UOffsetT(0)
	if t.ActualVelUnit != "" {
		actualVelUnitOffset = builder.CreateString(t.ActualVelUnit)
	}
	actualAccUnitOffset := flatbuffers.UOffsetT(0)
	if t.ActualAccUnit != "" {
		actualAccUnitOffset = builder.CreateString(t.ActualAccUnit)
	}
	AxsExtrapolatedActualValuesStart(builder)
	AxsExtrapolatedActualValuesAddActualPos(builder, t.ActualPos)
	AxsExtrapolatedActualValuesAddActualVel(builder, t.ActualVel)
	AxsExtrapolatedActualValuesAddActualAcc(builder, t.ActualAcc)
	AxsExtrapolatedActualValuesAddActualPosUnit(builder, actualPosUnitOffset)
	AxsExtrapolatedActualValuesAddActualVelUnit(builder, actualVelUnitOffset)
	AxsExtrapolatedActualValuesAddActualAccUnit(builder, actualAccUnitOffset)
	return AxsExtrapolatedActualValuesEnd(builder)
}

func (rcv *AxsExtrapolatedActualValues) UnPackTo(t *AxsExtrapolatedActualValuesT) {
	t.ActualPos = rcv.ActualPos()
	t.ActualVel = rcv.ActualVel()
	t.ActualAcc = rcv.ActualAcc()
	t.ActualPosUnit = string(rcv.ActualPosUnit())
	t.ActualVelUnit = string(rcv.ActualVelUnit())
	t.ActualAccUnit = string(rcv.ActualAccUnit())
}

func (rcv *AxsExtrapolatedActualValues) UnPack() *AxsExtrapolatedActualValuesT {
	if rcv == nil { return nil }
	t := &AxsExtrapolatedActualValuesT{}
	rcv.UnPackTo(t)
	return t
}

type AxsExtrapolatedActualValues struct {
	_tab flatbuffers.Table
}

func GetRootAsAxsExtrapolatedActualValues(buf []byte, offset flatbuffers.UOffsetT) *AxsExtrapolatedActualValues {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AxsExtrapolatedActualValues{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsAxsExtrapolatedActualValues(buf []byte, offset flatbuffers.UOffsetT) *AxsExtrapolatedActualValues {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AxsExtrapolatedActualValues{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *AxsExtrapolatedActualValues) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AxsExtrapolatedActualValues) Table() flatbuffers.Table {
	return rcv._tab
}

/// extrapolated actual position (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) ActualPos() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// extrapolated actual position (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) MutateActualPos(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// extrapolated actual velocity (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) ActualVel() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// extrapolated actual velocity (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) MutateActualVel(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// extrapolated actual acceleration (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) ActualAcc() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// extrapolated actual acceleration (only available, when extrapolation is activated and at least actual position is available)
func (rcv *AxsExtrapolatedActualValues) MutateActualAcc(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// unit of the extrapolated actual position
func (rcv *AxsExtrapolatedActualValues) ActualPosUnit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the extrapolated actual position
/// unit of the extrapolated actual velocity
func (rcv *AxsExtrapolatedActualValues) ActualVelUnit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the extrapolated actual velocity
/// unit of the extrapolated actual acceleration
func (rcv *AxsExtrapolatedActualValues) ActualAccUnit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// unit of the extrapolated actual acceleration
func AxsExtrapolatedActualValuesStart(builder *flatbuffers.Builder) {
	builder.StartObject(6)
}
func AxsExtrapolatedActualValuesAddActualPos(builder *flatbuffers.Builder, actualPos float64) {
	builder.PrependFloat64Slot(0, actualPos, 0.0)
}
func AxsExtrapolatedActualValuesAddActualVel(builder *flatbuffers.Builder, actualVel float64) {
	builder.PrependFloat64Slot(1, actualVel, 0.0)
}
func AxsExtrapolatedActualValuesAddActualAcc(builder *flatbuffers.Builder, actualAcc float64) {
	builder.PrependFloat64Slot(2, actualAcc, 0.0)
}
func AxsExtrapolatedActualValuesAddActualPosUnit(builder *flatbuffers.Builder, actualPosUnit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(actualPosUnit), 0)
}
func AxsExtrapolatedActualValuesAddActualVelUnit(builder *flatbuffers.Builder, actualVelUnit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(actualVelUnit), 0)
}
func AxsExtrapolatedActualValuesAddActualAccUnit(builder *flatbuffers.Builder, actualAccUnit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(actualAccUnit), 0)
}
func AxsExtrapolatedActualValuesEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
