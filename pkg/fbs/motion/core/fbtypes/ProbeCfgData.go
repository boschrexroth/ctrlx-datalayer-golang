// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// data of the axis probe 
type ProbeCfgDataT struct {
	MeasurSigSel string
	MeasurType string
	EvalEdgeType string
	EvalDiffType string
	ExpWindowEdgeEnable bool
	ExpWindowStart float64
	ExpWindowEnd float64
	EnableMarkFailure bool
	MaxNumOfMarkFailuer uint32
	TimeCompEnable bool
	TimeCompPosEdge float64
	TimeCompNegEdge float64
	LvlMonitorActive bool
	IsAutoActivated bool
}

func (t *ProbeCfgDataT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	measurSigSelOffset := builder.CreateString(t.MeasurSigSel)
	measurTypeOffset := builder.CreateString(t.MeasurType)
	evalEdgeTypeOffset := builder.CreateString(t.EvalEdgeType)
	evalDiffTypeOffset := builder.CreateString(t.EvalDiffType)
	ProbeCfgDataStart(builder)
	ProbeCfgDataAddMeasurSigSel(builder, measurSigSelOffset)
	ProbeCfgDataAddMeasurType(builder, measurTypeOffset)
	ProbeCfgDataAddEvalEdgeType(builder, evalEdgeTypeOffset)
	ProbeCfgDataAddEvalDiffType(builder, evalDiffTypeOffset)
	ProbeCfgDataAddExpWindowEdgeEnable(builder, t.ExpWindowEdgeEnable)
	ProbeCfgDataAddExpWindowStart(builder, t.ExpWindowStart)
	ProbeCfgDataAddExpWindowEnd(builder, t.ExpWindowEnd)
	ProbeCfgDataAddEnableMarkFailure(builder, t.EnableMarkFailure)
	ProbeCfgDataAddMaxNumOfMarkFailuer(builder, t.MaxNumOfMarkFailuer)
	ProbeCfgDataAddTimeCompEnable(builder, t.TimeCompEnable)
	ProbeCfgDataAddTimeCompPosEdge(builder, t.TimeCompPosEdge)
	ProbeCfgDataAddTimeCompNegEdge(builder, t.TimeCompNegEdge)
	ProbeCfgDataAddLvlMonitorActive(builder, t.LvlMonitorActive)
	ProbeCfgDataAddIsAutoActivated(builder, t.IsAutoActivated)
	return ProbeCfgDataEnd(builder)
}

func (rcv *ProbeCfgData) UnPackTo(t *ProbeCfgDataT) {
	t.MeasurSigSel = string(rcv.MeasurSigSel())
	t.MeasurType = string(rcv.MeasurType())
	t.EvalEdgeType = string(rcv.EvalEdgeType())
	t.EvalDiffType = string(rcv.EvalDiffType())
	t.ExpWindowEdgeEnable = rcv.ExpWindowEdgeEnable()
	t.ExpWindowStart = rcv.ExpWindowStart()
	t.ExpWindowEnd = rcv.ExpWindowEnd()
	t.EnableMarkFailure = rcv.EnableMarkFailure()
	t.MaxNumOfMarkFailuer = rcv.MaxNumOfMarkFailuer()
	t.TimeCompEnable = rcv.TimeCompEnable()
	t.TimeCompPosEdge = rcv.TimeCompPosEdge()
	t.TimeCompNegEdge = rcv.TimeCompNegEdge()
	t.LvlMonitorActive = rcv.LvlMonitorActive()
	t.IsAutoActivated = rcv.IsAutoActivated()
}

func (rcv *ProbeCfgData) UnPack() *ProbeCfgDataT {
	if rcv == nil { return nil }
	t := &ProbeCfgDataT{}
	rcv.UnPackTo(t)
	return t
}

type ProbeCfgData struct {
	_tab flatbuffers.Table
}

func GetRootAsProbeCfgData(buf []byte, offset flatbuffers.UOffsetT) *ProbeCfgData {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &ProbeCfgData{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsProbeCfgData(buf []byte, offset flatbuffers.UOffsetT) *ProbeCfgData {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &ProbeCfgData{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *ProbeCfgData) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *ProbeCfgData) Table() flatbuffers.Table {
	return rcv._tab
}

/// measuring signal select (e.g. "encoder1", "encoder2", "finetime")
func (rcv *ProbeCfgData) MeasurSigSel() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// measuring signal select (e.g. "encoder1", "encoder2", "finetime")
/// selection of measuring type (e.g. "continuous", "singleShot")
func (rcv *ProbeCfgData) MeasurType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// selection of measuring type (e.g. "continuous", "singleShot")
/// selection which edge is evaluated (e.g. "disabled", "posEdge", "negEdge", "posNeg")
func (rcv *ProbeCfgData) EvalEdgeType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// selection which edge is evaluated (e.g. "disabled", "posEdge", "negEdge", "posNeg")
/// probe difference measuring type (e.g. "disabled", "standard", "negToNeg", "posToNeg", "negToPos", "posToPos")
func (rcv *ProbeCfgData) EvalDiffType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// probe difference measuring type (e.g. "disabled", "standard", "negToNeg", "posToNeg", "negToPos", "posToPos")
/// enable of expectation window
func (rcv *ProbeCfgData) ExpWindowEdgeEnable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// enable of expectation window
func (rcv *ProbeCfgData) MutateExpWindowEdgeEnable(n bool) bool {
	return rcv._tab.MutateBoolSlot(12, n)
}

/// start of the expectation window if the positive edge is evaluated
func (rcv *ProbeCfgData) ExpWindowStart() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// start of the expectation window if the positive edge is evaluated
func (rcv *ProbeCfgData) MutateExpWindowStart(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// end of the expectation window if the positive edge is evaluated
func (rcv *ProbeCfgData) ExpWindowEnd() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// end of the expectation window if the positive edge is evaluated
func (rcv *ProbeCfgData) MutateExpWindowEnd(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// enable lost mark check
func (rcv *ProbeCfgData) EnableMarkFailure() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// enable lost mark check
func (rcv *ProbeCfgData) MutateEnableMarkFailure(n bool) bool {
	return rcv._tab.MutateBoolSlot(18, n)
}

/// threshold for the registered number of marker failure
func (rcv *ProbeCfgData) MaxNumOfMarkFailuer() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// threshold for the registered number of marker failure
func (rcv *ProbeCfgData) MutateMaxNumOfMarkFailuer(n uint32) bool {
	return rcv._tab.MutateUint32Slot(20, n)
}

/// probe dead time compensation enable
func (rcv *ProbeCfgData) TimeCompEnable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// probe dead time compensation enable
func (rcv *ProbeCfgData) MutateTimeCompEnable(n bool) bool {
	return rcv._tab.MutateBoolSlot(22, n)
}

/// dead time compensation for the positive edge if evaluated
func (rcv *ProbeCfgData) TimeCompPosEdge() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// dead time compensation for the positive edge if evaluated
func (rcv *ProbeCfgData) MutateTimeCompPosEdge(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// dead time compensation for the negative edge if evaluated
func (rcv *ProbeCfgData) TimeCompNegEdge() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// dead time compensation for the negative edge if evaluated
func (rcv *ProbeCfgData) MutateTimeCompNegEdge(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// switch-on level monitoring active, only worked for drive based touch probe 1
func (rcv *ProbeCfgData) LvlMonitorActive() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// switch-on level monitoring active, only worked for drive based touch probe 1
func (rcv *ProbeCfgData) MutateLvlMonitorActive(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

/// probe auto activated after config
func (rcv *ProbeCfgData) IsAutoActivated() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// probe auto activated after config
func (rcv *ProbeCfgData) MutateIsAutoActivated(n bool) bool {
	return rcv._tab.MutateBoolSlot(30, n)
}

func ProbeCfgDataStart(builder *flatbuffers.Builder) {
	builder.StartObject(14)
}
func ProbeCfgDataAddMeasurSigSel(builder *flatbuffers.Builder, measurSigSel flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(measurSigSel), 0)
}
func ProbeCfgDataAddMeasurType(builder *flatbuffers.Builder, measurType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(measurType), 0)
}
func ProbeCfgDataAddEvalEdgeType(builder *flatbuffers.Builder, evalEdgeType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(evalEdgeType), 0)
}
func ProbeCfgDataAddEvalDiffType(builder *flatbuffers.Builder, evalDiffType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(evalDiffType), 0)
}
func ProbeCfgDataAddExpWindowEdgeEnable(builder *flatbuffers.Builder, expWindowEdgeEnable bool) {
	builder.PrependBoolSlot(4, expWindowEdgeEnable, false)
}
func ProbeCfgDataAddExpWindowStart(builder *flatbuffers.Builder, expWindowStart float64) {
	builder.PrependFloat64Slot(5, expWindowStart, 0.0)
}
func ProbeCfgDataAddExpWindowEnd(builder *flatbuffers.Builder, expWindowEnd float64) {
	builder.PrependFloat64Slot(6, expWindowEnd, 0.0)
}
func ProbeCfgDataAddEnableMarkFailure(builder *flatbuffers.Builder, enableMarkFailure bool) {
	builder.PrependBoolSlot(7, enableMarkFailure, false)
}
func ProbeCfgDataAddMaxNumOfMarkFailuer(builder *flatbuffers.Builder, maxNumOfMarkFailuer uint32) {
	builder.PrependUint32Slot(8, maxNumOfMarkFailuer, 0)
}
func ProbeCfgDataAddTimeCompEnable(builder *flatbuffers.Builder, timeCompEnable bool) {
	builder.PrependBoolSlot(9, timeCompEnable, false)
}
func ProbeCfgDataAddTimeCompPosEdge(builder *flatbuffers.Builder, timeCompPosEdge float64) {
	builder.PrependFloat64Slot(10, timeCompPosEdge, 0.0)
}
func ProbeCfgDataAddTimeCompNegEdge(builder *flatbuffers.Builder, timeCompNegEdge float64) {
	builder.PrependFloat64Slot(11, timeCompNegEdge, 0.0)
}
func ProbeCfgDataAddLvlMonitorActive(builder *flatbuffers.Builder, lvlMonitorActive bool) {
	builder.PrependBoolSlot(12, lvlMonitorActive, false)
}
func ProbeCfgDataAddIsAutoActivated(builder *flatbuffers.Builder, isAutoActivated bool) {
	builder.PrependBoolSlot(13, isAutoActivated, false)
}
func ProbeCfgDataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
