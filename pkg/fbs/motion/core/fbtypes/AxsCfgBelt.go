// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// configuration of motion function 'belt axis'
type AxsCfgBeltT struct {
	IsBeltAxis bool `json:"isBeltAxis"`
	BeltValConversionFactor float64 `json:"beltValConversionFactor"`
	BeltCoordSysNameDefault string `json:"beltCoordSysNameDefault"`
	NominatorUnitOfBeltConversionFactor string `json:"nominatorUnitOfBeltConversionFactor"`
	DenominatorUnitOfBeltConversionFactor string `json:"denominatorUnitOfBeltConversionFactor"`
}

func (t *AxsCfgBeltT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	beltCoordSysNameDefaultOffset := flatbuffers.UOffsetT(0)
	if t.BeltCoordSysNameDefault != "" {
		beltCoordSysNameDefaultOffset = builder.CreateString(t.BeltCoordSysNameDefault)
	}
	nominatorUnitOfBeltConversionFactorOffset := flatbuffers.UOffsetT(0)
	if t.NominatorUnitOfBeltConversionFactor != "" {
		nominatorUnitOfBeltConversionFactorOffset = builder.CreateString(t.NominatorUnitOfBeltConversionFactor)
	}
	denominatorUnitOfBeltConversionFactorOffset := flatbuffers.UOffsetT(0)
	if t.DenominatorUnitOfBeltConversionFactor != "" {
		denominatorUnitOfBeltConversionFactorOffset = builder.CreateString(t.DenominatorUnitOfBeltConversionFactor)
	}
	AxsCfgBeltStart(builder)
	AxsCfgBeltAddIsBeltAxis(builder, t.IsBeltAxis)
	AxsCfgBeltAddBeltValConversionFactor(builder, t.BeltValConversionFactor)
	AxsCfgBeltAddBeltCoordSysNameDefault(builder, beltCoordSysNameDefaultOffset)
	AxsCfgBeltAddNominatorUnitOfBeltConversionFactor(builder, nominatorUnitOfBeltConversionFactorOffset)
	AxsCfgBeltAddDenominatorUnitOfBeltConversionFactor(builder, denominatorUnitOfBeltConversionFactorOffset)
	return AxsCfgBeltEnd(builder)
}

func (rcv *AxsCfgBelt) UnPackTo(t *AxsCfgBeltT) {
	t.IsBeltAxis = rcv.IsBeltAxis()
	t.BeltValConversionFactor = rcv.BeltValConversionFactor()
	t.BeltCoordSysNameDefault = string(rcv.BeltCoordSysNameDefault())
	t.NominatorUnitOfBeltConversionFactor = string(rcv.NominatorUnitOfBeltConversionFactor())
	t.DenominatorUnitOfBeltConversionFactor = string(rcv.DenominatorUnitOfBeltConversionFactor())
}

func (rcv *AxsCfgBelt) UnPack() *AxsCfgBeltT {
	if rcv == nil { return nil }
	t := &AxsCfgBeltT{}
	rcv.UnPackTo(t)
	return t
}

type AxsCfgBelt struct {
	_tab flatbuffers.Table
}

func GetRootAsAxsCfgBelt(buf []byte, offset flatbuffers.UOffsetT) *AxsCfgBelt {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &AxsCfgBelt{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsAxsCfgBelt(buf []byte, offset flatbuffers.UOffsetT) *AxsCfgBelt {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &AxsCfgBelt{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *AxsCfgBelt) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *AxsCfgBelt) Table() flatbuffers.Table {
	return rcv._tab
}

/// flag to configure if the axis is a belt axis
func (rcv *AxsCfgBelt) IsBeltAxis() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// flag to configure if the axis is a belt axis
func (rcv *AxsCfgBelt) MutateIsBeltAxis(n bool) bool {
	return rcv._tab.MutateBoolSlot(4, n)
}

/// conversion factor between beltValue and axis value
func (rcv *AxsCfgBelt) BeltValConversionFactor() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// conversion factor between beltValue and axis value
func (rcv *AxsCfgBelt) MutateBeltValConversionFactor(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// name of the default coordinate system of the belt
func (rcv *AxsCfgBelt) BeltCoordSysNameDefault() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// name of the default coordinate system of the belt
/// nominator unit part of the belt conversion factor ("Must be set for writing. If not set when reading, the unit from the belt configuration is used.")
func (rcv *AxsCfgBelt) NominatorUnitOfBeltConversionFactor() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// nominator unit part of the belt conversion factor ("Must be set for writing. If not set when reading, the unit from the belt configuration is used.")
/// denominator unit part of the belt conversion factor ("If not set, the standard unit of the axis is used.")
func (rcv *AxsCfgBelt) DenominatorUnitOfBeltConversionFactor() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// denominator unit part of the belt conversion factor ("If not set, the standard unit of the axis is used.")
func AxsCfgBeltStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func AxsCfgBeltAddIsBeltAxis(builder *flatbuffers.Builder, isBeltAxis bool) {
	builder.PrependBoolSlot(0, isBeltAxis, false)
}
func AxsCfgBeltAddBeltValConversionFactor(builder *flatbuffers.Builder, beltValConversionFactor float64) {
	builder.PrependFloat64Slot(1, beltValConversionFactor, 0.0)
}
func AxsCfgBeltAddBeltCoordSysNameDefault(builder *flatbuffers.Builder, beltCoordSysNameDefault flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(beltCoordSysNameDefault), 0)
}
func AxsCfgBeltAddNominatorUnitOfBeltConversionFactor(builder *flatbuffers.Builder, nominatorUnitOfBeltConversionFactor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(nominatorUnitOfBeltConversionFactor), 0)
}
func AxsCfgBeltAddDenominatorUnitOfBeltConversionFactor(builder *flatbuffers.Builder, denominatorUnitOfBeltConversionFactor flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(denominatorUnitOfBeltConversionFactor), 0)
}
func AxsCfgBeltEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
