// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// configuration of a FlexProfile segment
type CfgFlexProfileSegmentT struct {
	Gain float64 `json:"gain"`
	Range float64 `json:"range"`
	V0 float64 `json:"v0"`
	A0 float64 `json:"a0"`
	J0 float64 `json:"j0"`
	V1 float64 `json:"v1"`
	A1 float64 `json:"a1"`
	J1 float64 `json:"j1"`
	LimV float64 `json:"limV"`
	LimA0 float64 `json:"limA0"`
	LimA1 float64 `json:"limA1"`
	LimJ0 float64 `json:"limJ0"`
	LimJ1 float64 `json:"limJ1"`
	Lambda float64 `json:"lambda"`
	SyncType SegmentSyncType `json:"syncType"`
	LawType SegmentLawType `json:"lawType"`
	PointTableReference string `json:"pointTableReference"`
	Master uint32 `json:"master"`
	CamBuilderSegmentData string `json:"camBuilderSegmentData"`
}

func (t *CfgFlexProfileSegmentT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	pointTableReferenceOffset := flatbuffers.UOffsetT(0)
	if t.PointTableReference != "" {
		pointTableReferenceOffset = builder.CreateString(t.PointTableReference)
	}
	camBuilderSegmentDataOffset := flatbuffers.UOffsetT(0)
	if t.CamBuilderSegmentData != "" {
		camBuilderSegmentDataOffset = builder.CreateString(t.CamBuilderSegmentData)
	}
	CfgFlexProfileSegmentStart(builder)
	CfgFlexProfileSegmentAddGain(builder, t.Gain)
	CfgFlexProfileSegmentAddRange(builder, t.Range)
	CfgFlexProfileSegmentAddV0(builder, t.V0)
	CfgFlexProfileSegmentAddA0(builder, t.A0)
	CfgFlexProfileSegmentAddJ0(builder, t.J0)
	CfgFlexProfileSegmentAddV1(builder, t.V1)
	CfgFlexProfileSegmentAddA1(builder, t.A1)
	CfgFlexProfileSegmentAddJ1(builder, t.J1)
	CfgFlexProfileSegmentAddLimV(builder, t.LimV)
	CfgFlexProfileSegmentAddLimA0(builder, t.LimA0)
	CfgFlexProfileSegmentAddLimA1(builder, t.LimA1)
	CfgFlexProfileSegmentAddLimJ0(builder, t.LimJ0)
	CfgFlexProfileSegmentAddLimJ1(builder, t.LimJ1)
	CfgFlexProfileSegmentAddLambda(builder, t.Lambda)
	CfgFlexProfileSegmentAddSyncType(builder, t.SyncType)
	CfgFlexProfileSegmentAddLawType(builder, t.LawType)
	CfgFlexProfileSegmentAddPointTableReference(builder, pointTableReferenceOffset)
	CfgFlexProfileSegmentAddMaster(builder, t.Master)
	CfgFlexProfileSegmentAddCamBuilderSegmentData(builder, camBuilderSegmentDataOffset)
	return CfgFlexProfileSegmentEnd(builder)
}

func (rcv *CfgFlexProfileSegment) UnPackTo(t *CfgFlexProfileSegmentT) {
	t.Gain = rcv.Gain()
	t.Range = rcv.Range()
	t.V0 = rcv.V0()
	t.A0 = rcv.A0()
	t.J0 = rcv.J0()
	t.V1 = rcv.V1()
	t.A1 = rcv.A1()
	t.J1 = rcv.J1()
	t.LimV = rcv.LimV()
	t.LimA0 = rcv.LimA0()
	t.LimA1 = rcv.LimA1()
	t.LimJ0 = rcv.LimJ0()
	t.LimJ1 = rcv.LimJ1()
	t.Lambda = rcv.Lambda()
	t.SyncType = rcv.SyncType()
	t.LawType = rcv.LawType()
	t.PointTableReference = string(rcv.PointTableReference())
	t.Master = rcv.Master()
	t.CamBuilderSegmentData = string(rcv.CamBuilderSegmentData())
}

func (rcv *CfgFlexProfileSegment) UnPack() *CfgFlexProfileSegmentT {
	if rcv == nil { return nil }
	t := &CfgFlexProfileSegmentT{}
	rcv.UnPackTo(t)
	return t
}

type CfgFlexProfileSegment struct {
	_tab flatbuffers.Table
}

func GetRootAsCfgFlexProfileSegment(buf []byte, offset flatbuffers.UOffsetT) *CfgFlexProfileSegment {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CfgFlexProfileSegment{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCfgFlexProfileSegment(buf []byte, offset flatbuffers.UOffsetT) *CfgFlexProfileSegment {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CfgFlexProfileSegment{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CfgFlexProfileSegment) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CfgFlexProfileSegment) Table() flatbuffers.Table {
	return rcv._tab
}

/// Gain/hub/lift of segment - slave range  (Y)   // Units
func (rcv *CfgFlexProfileSegment) Gain() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Gain/hub/lift of segment - slave range  (Y)   // Units
func (rcv *CfgFlexProfileSegment) MutateGain(n float64) bool {
	return rcv._tab.MutateFloat64Slot(4, n)
}

/// Range of segment         - master range (X)   // Units
func (rcv *CfgFlexProfileSegment) Range() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Range of segment         - master range (X)   // Units
func (rcv *CfgFlexProfileSegment) MutateRange(n float64) bool {
	return rcv._tab.MutateFloat64Slot(6, n)
}

/// Start Velocity                                // Units/s
func (rcv *CfgFlexProfileSegment) V0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Start Velocity                                // Units/s
func (rcv *CfgFlexProfileSegment) MutateV0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(8, n)
}

/// Start Acceleration                            // Units/s^2
func (rcv *CfgFlexProfileSegment) A0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Start Acceleration                            // Units/s^2
func (rcv *CfgFlexProfileSegment) MutateA0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(10, n)
}

/// Start Jerk                                    // Units/s^3
func (rcv *CfgFlexProfileSegment) J0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Start Jerk                                    // Units/s^3
func (rcv *CfgFlexProfileSegment) MutateJ0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(12, n)
}

/// End Velocity                                  // Units/s
func (rcv *CfgFlexProfileSegment) V1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// End Velocity                                  // Units/s
func (rcv *CfgFlexProfileSegment) MutateV1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// End Acceleration                              // Units/s^2
func (rcv *CfgFlexProfileSegment) A1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// End Acceleration                              // Units/s^2
func (rcv *CfgFlexProfileSegment) MutateA1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// End Jerk                                      // Units/s^3
func (rcv *CfgFlexProfileSegment) J1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// End Jerk                                      // Units/s^3
func (rcv *CfgFlexProfileSegment) MutateJ1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(18, n)
}

/// Travel/Limit Velocity                         // Units/s
func (rcv *CfgFlexProfileSegment) LimV() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Travel/Limit Velocity                         // Units/s
func (rcv *CfgFlexProfileSegment) MutateLimV(n float64) bool {
	return rcv._tab.MutateFloat64Slot(20, n)
}

/// Travel/Limit Acc                              // Units/s^2
func (rcv *CfgFlexProfileSegment) LimA0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Travel/Limit Acc                              // Units/s^2
func (rcv *CfgFlexProfileSegment) MutateLimA0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(22, n)
}

/// Travel/Limit Dec                              // Units/s^2
func (rcv *CfgFlexProfileSegment) LimA1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Travel/Limit Dec                              // Units/s^2
func (rcv *CfgFlexProfileSegment) MutateLimA1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// Travel/Limit Acc-Jerk                         // Units/s^3
func (rcv *CfgFlexProfileSegment) LimJ0() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Travel/Limit Acc-Jerk                         // Units/s^3
func (rcv *CfgFlexProfileSegment) MutateLimJ0(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// Travel/Limit Acc-Jerk                         // Units/s^3
func (rcv *CfgFlexProfileSegment) LimJ1() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Travel/Limit Acc-Jerk                         // Units/s^3
func (rcv *CfgFlexProfileSegment) MutateLimJ1(n float64) bool {
	return rcv._tab.MutateFloat64Slot(28, n)
}

/// Inflection point (Range 0.0 to 1.0)
func (rcv *CfgFlexProfileSegment) Lambda() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// Inflection point (Range 0.0 to 1.0)
func (rcv *CfgFlexProfileSegment) MutateLambda(n float64) bool {
	return rcv._tab.MutateFloat64Slot(30, n)
}

/// Type of the segment transition (fixed or flexible)
func (rcv *CfgFlexProfileSegment) SyncType() SegmentSyncType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return SegmentSyncType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of the segment transition (fixed or flexible)
func (rcv *CfgFlexProfileSegment) MutateSyncType(n SegmentSyncType) bool {
	return rcv._tab.MutateInt8Slot(32, int8(n))
}

/// Type of the law (e.g. Polynomial 5th order)
func (rcv *CfgFlexProfileSegment) LawType() SegmentLawType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return SegmentLawType(rcv._tab.GetUint32(o + rcv._tab.Pos))
	}
	return 0
}

/// Type of the law (e.g. Polynomial 5th order)
func (rcv *CfgFlexProfileSegment) MutateLawType(n SegmentLawType) bool {
	return rcv._tab.MutateUint32Slot(34, uint32(n))
}

/// Name of the referenced point table for dedicated motion laws
func (rcv *CfgFlexProfileSegment) PointTableReference() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Name of the referenced point table for dedicated motion laws
/// Type of the master (FML_MasterType - axis or time)
func (rcv *CfgFlexProfileSegment) Master() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// Type of the master (FML_MasterType - axis or time)
func (rcv *CfgFlexProfileSegment) MutateMaster(n uint32) bool {
	return rcv._tab.MutateUint32Slot(38, n)
}

/// cam builder data (segment specific)
func (rcv *CfgFlexProfileSegment) CamBuilderSegmentData() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// cam builder data (segment specific)
func CfgFlexProfileSegmentStart(builder *flatbuffers.Builder) {
	builder.StartObject(19)
}
func CfgFlexProfileSegmentAddGain(builder *flatbuffers.Builder, gain float64) {
	builder.PrependFloat64Slot(0, gain, 0.0)
}
func CfgFlexProfileSegmentAddRange(builder *flatbuffers.Builder, range_ float64) {
	builder.PrependFloat64Slot(1, range_, 0.0)
}
func CfgFlexProfileSegmentAddV0(builder *flatbuffers.Builder, v0 float64) {
	builder.PrependFloat64Slot(2, v0, 0.0)
}
func CfgFlexProfileSegmentAddA0(builder *flatbuffers.Builder, a0 float64) {
	builder.PrependFloat64Slot(3, a0, 0.0)
}
func CfgFlexProfileSegmentAddJ0(builder *flatbuffers.Builder, j0 float64) {
	builder.PrependFloat64Slot(4, j0, 0.0)
}
func CfgFlexProfileSegmentAddV1(builder *flatbuffers.Builder, v1 float64) {
	builder.PrependFloat64Slot(5, v1, 0.0)
}
func CfgFlexProfileSegmentAddA1(builder *flatbuffers.Builder, a1 float64) {
	builder.PrependFloat64Slot(6, a1, 0.0)
}
func CfgFlexProfileSegmentAddJ1(builder *flatbuffers.Builder, j1 float64) {
	builder.PrependFloat64Slot(7, j1, 0.0)
}
func CfgFlexProfileSegmentAddLimV(builder *flatbuffers.Builder, limV float64) {
	builder.PrependFloat64Slot(8, limV, 0.0)
}
func CfgFlexProfileSegmentAddLimA0(builder *flatbuffers.Builder, limA0 float64) {
	builder.PrependFloat64Slot(9, limA0, 0.0)
}
func CfgFlexProfileSegmentAddLimA1(builder *flatbuffers.Builder, limA1 float64) {
	builder.PrependFloat64Slot(10, limA1, 0.0)
}
func CfgFlexProfileSegmentAddLimJ0(builder *flatbuffers.Builder, limJ0 float64) {
	builder.PrependFloat64Slot(11, limJ0, 0.0)
}
func CfgFlexProfileSegmentAddLimJ1(builder *flatbuffers.Builder, limJ1 float64) {
	builder.PrependFloat64Slot(12, limJ1, 0.0)
}
func CfgFlexProfileSegmentAddLambda(builder *flatbuffers.Builder, lambda float64) {
	builder.PrependFloat64Slot(13, lambda, 0.0)
}
func CfgFlexProfileSegmentAddSyncType(builder *flatbuffers.Builder, syncType SegmentSyncType) {
	builder.PrependInt8Slot(14, int8(syncType), 0)
}
func CfgFlexProfileSegmentAddLawType(builder *flatbuffers.Builder, lawType SegmentLawType) {
	builder.PrependUint32Slot(15, uint32(lawType), 0)
}
func CfgFlexProfileSegmentAddPointTableReference(builder *flatbuffers.Builder, pointTableReference flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(16, flatbuffers.UOffsetT(pointTableReference), 0)
}
func CfgFlexProfileSegmentAddMaster(builder *flatbuffers.Builder, master uint32) {
	builder.PrependUint32Slot(17, master, 0)
}
func CfgFlexProfileSegmentAddCamBuilderSegmentData(builder *flatbuffers.Builder, camBuilderSegmentData flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(camBuilderSegmentData), 0)
}
func CfgFlexProfileSegmentEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
