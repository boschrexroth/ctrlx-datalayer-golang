// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbtypes

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

/// data of the axis probe 
type CfgProbeDataT struct {
	MeasurSigSel string `json:"measurSigSel"`
	MeasurType string `json:"measurType"`
	EvalEdgeType string `json:"evalEdgeType"`
	EvalDiffType string `json:"evalDiffType"`
	ExpWindowEdgeEnable bool `json:"expWindowEdgeEnable"`
	ExpWindowStart float64 `json:"expWindowStart"`
	ExpWindowEnd float64 `json:"expWindowEnd"`
	EnableMarkFailure bool `json:"enableMarkFailure"`
	MaxNumOfMarkFailuer uint32 `json:"maxNumOfMarkFailuer"`
	TimeCompEnable bool `json:"timeCompEnable"`
	TimeCompPosEdge float64 `json:"timeCompPosEdge"`
	TimeCompNegEdge float64 `json:"timeCompNegEdge"`
	LvlMonitorActive bool `json:"lvlMonitorActive"`
	IsAutoActivated bool `json:"isAutoActivated"`
}

func (t *CfgProbeDataT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	measurSigSelOffset := flatbuffers.UOffsetT(0)
	if t.MeasurSigSel != "" {
		measurSigSelOffset = builder.CreateString(t.MeasurSigSel)
	}
	measurTypeOffset := flatbuffers.UOffsetT(0)
	if t.MeasurType != "" {
		measurTypeOffset = builder.CreateString(t.MeasurType)
	}
	evalEdgeTypeOffset := flatbuffers.UOffsetT(0)
	if t.EvalEdgeType != "" {
		evalEdgeTypeOffset = builder.CreateString(t.EvalEdgeType)
	}
	evalDiffTypeOffset := flatbuffers.UOffsetT(0)
	if t.EvalDiffType != "" {
		evalDiffTypeOffset = builder.CreateString(t.EvalDiffType)
	}
	CfgProbeDataStart(builder)
	CfgProbeDataAddMeasurSigSel(builder, measurSigSelOffset)
	CfgProbeDataAddMeasurType(builder, measurTypeOffset)
	CfgProbeDataAddEvalEdgeType(builder, evalEdgeTypeOffset)
	CfgProbeDataAddEvalDiffType(builder, evalDiffTypeOffset)
	CfgProbeDataAddExpWindowEdgeEnable(builder, t.ExpWindowEdgeEnable)
	CfgProbeDataAddExpWindowStart(builder, t.ExpWindowStart)
	CfgProbeDataAddExpWindowEnd(builder, t.ExpWindowEnd)
	CfgProbeDataAddEnableMarkFailure(builder, t.EnableMarkFailure)
	CfgProbeDataAddMaxNumOfMarkFailuer(builder, t.MaxNumOfMarkFailuer)
	CfgProbeDataAddTimeCompEnable(builder, t.TimeCompEnable)
	CfgProbeDataAddTimeCompPosEdge(builder, t.TimeCompPosEdge)
	CfgProbeDataAddTimeCompNegEdge(builder, t.TimeCompNegEdge)
	CfgProbeDataAddLvlMonitorActive(builder, t.LvlMonitorActive)
	CfgProbeDataAddIsAutoActivated(builder, t.IsAutoActivated)
	return CfgProbeDataEnd(builder)
}

func (rcv *CfgProbeData) UnPackTo(t *CfgProbeDataT) {
	t.MeasurSigSel = string(rcv.MeasurSigSel())
	t.MeasurType = string(rcv.MeasurType())
	t.EvalEdgeType = string(rcv.EvalEdgeType())
	t.EvalDiffType = string(rcv.EvalDiffType())
	t.ExpWindowEdgeEnable = rcv.ExpWindowEdgeEnable()
	t.ExpWindowStart = rcv.ExpWindowStart()
	t.ExpWindowEnd = rcv.ExpWindowEnd()
	t.EnableMarkFailure = rcv.EnableMarkFailure()
	t.MaxNumOfMarkFailuer = rcv.MaxNumOfMarkFailuer()
	t.TimeCompEnable = rcv.TimeCompEnable()
	t.TimeCompPosEdge = rcv.TimeCompPosEdge()
	t.TimeCompNegEdge = rcv.TimeCompNegEdge()
	t.LvlMonitorActive = rcv.LvlMonitorActive()
	t.IsAutoActivated = rcv.IsAutoActivated()
}

func (rcv *CfgProbeData) UnPack() *CfgProbeDataT {
	if rcv == nil { return nil }
	t := &CfgProbeDataT{}
	rcv.UnPackTo(t)
	return t
}

type CfgProbeData struct {
	_tab flatbuffers.Table
}

func GetRootAsCfgProbeData(buf []byte, offset flatbuffers.UOffsetT) *CfgProbeData {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &CfgProbeData{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsCfgProbeData(buf []byte, offset flatbuffers.UOffsetT) *CfgProbeData {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &CfgProbeData{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *CfgProbeData) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *CfgProbeData) Table() flatbuffers.Table {
	return rcv._tab
}

/// measuring signal select
func (rcv *CfgProbeData) MeasurSigSel() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// measuring signal select
/// selection of measuring type
func (rcv *CfgProbeData) MeasurType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// selection of measuring type
/// selection which edge is evaluated
func (rcv *CfgProbeData) EvalEdgeType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// selection which edge is evaluated
/// probe difference measuring type
func (rcv *CfgProbeData) EvalDiffType() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// probe difference measuring type
/// enable of expectation window
func (rcv *CfgProbeData) ExpWindowEdgeEnable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// enable of expectation window
func (rcv *CfgProbeData) MutateExpWindowEdgeEnable(n bool) bool {
	return rcv._tab.MutateBoolSlot(12, n)
}

/// start of the expectation window if the positive edge is evaluated
func (rcv *CfgProbeData) ExpWindowStart() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// start of the expectation window if the positive edge is evaluated
func (rcv *CfgProbeData) MutateExpWindowStart(n float64) bool {
	return rcv._tab.MutateFloat64Slot(14, n)
}

/// end of the expectation window if the positive edge is evaluated
func (rcv *CfgProbeData) ExpWindowEnd() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// end of the expectation window if the positive edge is evaluated
func (rcv *CfgProbeData) MutateExpWindowEnd(n float64) bool {
	return rcv._tab.MutateFloat64Slot(16, n)
}

/// enable lost mark check
func (rcv *CfgProbeData) EnableMarkFailure() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// enable lost mark check
func (rcv *CfgProbeData) MutateEnableMarkFailure(n bool) bool {
	return rcv._tab.MutateBoolSlot(18, n)
}

/// threshold for the registered number of marker failure
func (rcv *CfgProbeData) MaxNumOfMarkFailuer() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

/// threshold for the registered number of marker failure
func (rcv *CfgProbeData) MutateMaxNumOfMarkFailuer(n uint32) bool {
	return rcv._tab.MutateUint32Slot(20, n)
}

/// probe dead time compensation enable
func (rcv *CfgProbeData) TimeCompEnable() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// probe dead time compensation enable
func (rcv *CfgProbeData) MutateTimeCompEnable(n bool) bool {
	return rcv._tab.MutateBoolSlot(22, n)
}

/// dead time compensation for the positive edge if evaluated
func (rcv *CfgProbeData) TimeCompPosEdge() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// dead time compensation for the positive edge if evaluated
func (rcv *CfgProbeData) MutateTimeCompPosEdge(n float64) bool {
	return rcv._tab.MutateFloat64Slot(24, n)
}

/// dead time compensation for the negative edge if evaluated
func (rcv *CfgProbeData) TimeCompNegEdge() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

/// dead time compensation for the negative edge if evaluated
func (rcv *CfgProbeData) MutateTimeCompNegEdge(n float64) bool {
	return rcv._tab.MutateFloat64Slot(26, n)
}

/// switch-on level monitoring active, only worked for drive based touch probe 1
func (rcv *CfgProbeData) LvlMonitorActive() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// switch-on level monitoring active, only worked for drive based touch probe 1
func (rcv *CfgProbeData) MutateLvlMonitorActive(n bool) bool {
	return rcv._tab.MutateBoolSlot(28, n)
}

/// probe auto activated after config
func (rcv *CfgProbeData) IsAutoActivated() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

/// probe auto activated after config
func (rcv *CfgProbeData) MutateIsAutoActivated(n bool) bool {
	return rcv._tab.MutateBoolSlot(30, n)
}

func CfgProbeDataStart(builder *flatbuffers.Builder) {
	builder.StartObject(14)
}
func CfgProbeDataAddMeasurSigSel(builder *flatbuffers.Builder, measurSigSel flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(measurSigSel), 0)
}
func CfgProbeDataAddMeasurType(builder *flatbuffers.Builder, measurType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(measurType), 0)
}
func CfgProbeDataAddEvalEdgeType(builder *flatbuffers.Builder, evalEdgeType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(evalEdgeType), 0)
}
func CfgProbeDataAddEvalDiffType(builder *flatbuffers.Builder, evalDiffType flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(evalDiffType), 0)
}
func CfgProbeDataAddExpWindowEdgeEnable(builder *flatbuffers.Builder, expWindowEdgeEnable bool) {
	builder.PrependBoolSlot(4, expWindowEdgeEnable, false)
}
func CfgProbeDataAddExpWindowStart(builder *flatbuffers.Builder, expWindowStart float64) {
	builder.PrependFloat64Slot(5, expWindowStart, 0.0)
}
func CfgProbeDataAddExpWindowEnd(builder *flatbuffers.Builder, expWindowEnd float64) {
	builder.PrependFloat64Slot(6, expWindowEnd, 0.0)
}
func CfgProbeDataAddEnableMarkFailure(builder *flatbuffers.Builder, enableMarkFailure bool) {
	builder.PrependBoolSlot(7, enableMarkFailure, false)
}
func CfgProbeDataAddMaxNumOfMarkFailuer(builder *flatbuffers.Builder, maxNumOfMarkFailuer uint32) {
	builder.PrependUint32Slot(8, maxNumOfMarkFailuer, 0)
}
func CfgProbeDataAddTimeCompEnable(builder *flatbuffers.Builder, timeCompEnable bool) {
	builder.PrependBoolSlot(9, timeCompEnable, false)
}
func CfgProbeDataAddTimeCompPosEdge(builder *flatbuffers.Builder, timeCompPosEdge float64) {
	builder.PrependFloat64Slot(10, timeCompPosEdge, 0.0)
}
func CfgProbeDataAddTimeCompNegEdge(builder *flatbuffers.Builder, timeCompNegEdge float64) {
	builder.PrependFloat64Slot(11, timeCompNegEdge, 0.0)
}
func CfgProbeDataAddLvlMonitorActive(builder *flatbuffers.Builder, lvlMonitorActive bool) {
	builder.PrependBoolSlot(12, lvlMonitorActive, false)
}
func CfgProbeDataAddIsAutoActivated(builder *flatbuffers.Builder, isAutoActivated bool) {
	builder.PrependBoolSlot(13, isAutoActivated, false)
}
func CfgProbeDataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
