// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbs

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

///Interface response
type InterfaceT struct {
	Port string `json:"port"`
	Device string `json:"device"`
	LinkLayer string `json:"linkLayer"`
	CapabilityList []*CapabilityT `json:"capabilityList"`
	Reference string `json:"reference"`
}

func (t *InterfaceT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	portOffset := flatbuffers.UOffsetT(0)
	if t.Port != "" {
		portOffset = builder.CreateString(t.Port)
	}
	deviceOffset := flatbuffers.UOffsetT(0)
	if t.Device != "" {
		deviceOffset = builder.CreateString(t.Device)
	}
	linkLayerOffset := flatbuffers.UOffsetT(0)
	if t.LinkLayer != "" {
		linkLayerOffset = builder.CreateString(t.LinkLayer)
	}
	capabilityListOffset := flatbuffers.UOffsetT(0)
	if t.CapabilityList != nil {
		capabilityListLength := len(t.CapabilityList)
		capabilityListOffsets := make([]flatbuffers.UOffsetT, capabilityListLength)
		for j := 0; j < capabilityListLength; j++ {
			capabilityListOffsets[j] = t.CapabilityList[j].Pack(builder)
		}
		InterfaceStartCapabilityListVector(builder, capabilityListLength)
		for j := capabilityListLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(capabilityListOffsets[j])
		}
		capabilityListOffset = builder.EndVector(capabilityListLength)
	}
	referenceOffset := flatbuffers.UOffsetT(0)
	if t.Reference != "" {
		referenceOffset = builder.CreateString(t.Reference)
	}
	InterfaceStart(builder)
	InterfaceAddPort(builder, portOffset)
	InterfaceAddDevice(builder, deviceOffset)
	InterfaceAddLinkLayer(builder, linkLayerOffset)
	InterfaceAddCapabilityList(builder, capabilityListOffset)
	InterfaceAddReference(builder, referenceOffset)
	return InterfaceEnd(builder)
}

func (rcv *Interface) UnPackTo(t *InterfaceT) {
	t.Port = string(rcv.Port())
	t.Device = string(rcv.Device())
	t.LinkLayer = string(rcv.LinkLayer())
	capabilityListLength := rcv.CapabilityListLength()
	t.CapabilityList = make([]*CapabilityT, capabilityListLength)
	for j := 0; j < capabilityListLength; j++ {
		x := Capability{}
		rcv.CapabilityList(&x, j)
		t.CapabilityList[j] = x.UnPack()
	}
	t.Reference = string(rcv.Reference())
}

func (rcv *Interface) UnPack() *InterfaceT {
	if rcv == nil { return nil }
	t := &InterfaceT{}
	rcv.UnPackTo(t)
	return t
}

type Interface struct {
	_tab flatbuffers.Table
}

func GetRootAsInterface(buf []byte, offset flatbuffers.UOffsetT) *Interface {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Interface{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsInterface(buf []byte, offset flatbuffers.UOffsetT) *Interface {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Interface{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Interface) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Interface) Table() flatbuffers.Table {
	return rcv._tab
}

///Port name, e.g. as written on device
func (rcv *Interface) Port() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///Port name, e.g. as written on device
///Reserved for future use
func (rcv *Interface) Device() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///Reserved for future use
///Link layer driver
func (rcv *Interface) LinkLayer() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///Link layer driver
///Reserved for future use
func (rcv *Interface) CapabilityList(obj *Capability, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Interface) CapabilityListLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///Reserved for future use
///Reference to application
///empty: not referenced
///datalayer path: referenced by known application e.g. fieldbuses/ethercat/master/instances/ethercatmaster
///UNKNOWN: referenced by unknown application
func (rcv *Interface) Reference() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///Reference to application
///empty: not referenced
///datalayer path: referenced by known application e.g. fieldbuses/ethercat/master/instances/ethercatmaster
///UNKNOWN: referenced by unknown application
func InterfaceStart(builder *flatbuffers.Builder) {
	builder.StartObject(5)
}
func InterfaceAddPort(builder *flatbuffers.Builder, port flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(port), 0)
}
func InterfaceAddDevice(builder *flatbuffers.Builder, device flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(device), 0)
}
func InterfaceAddLinkLayer(builder *flatbuffers.Builder, linkLayer flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(linkLayer), 0)
}
func InterfaceAddCapabilityList(builder *flatbuffers.Builder, capabilityList flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(capabilityList), 0)
}
func InterfaceStartCapabilityListVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func InterfaceAddReference(builder *flatbuffers.Builder, reference flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(reference), 0)
}
func InterfaceEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
