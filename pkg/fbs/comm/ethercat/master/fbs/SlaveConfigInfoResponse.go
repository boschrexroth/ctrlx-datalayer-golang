// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package fbs

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

///Slave configuration response
type SlaveConfigInfoResponseT struct {
	AutoIncAddr uint16 `json:"autoIncAddr"`
	EthercatAddr uint16 `json:"ethercatAddr"`
	IdentifyAdo uint16 `json:"identifyAdo"`
	IdentifyValue uint16 `json:"identifyValue"`
	SlaveHandle uint32 `json:"slaveHandle"`
	HcGroupIdx uint32 `json:"hcGroupIdx"`
	PreviousEthercatAddr uint16 `json:"previousEthercatAddr"`
	PreviousPort uint16 `json:"previousPort"`
	SlaveIdentity *EthercatIdentityInfoT `json:"slaveIdentity"`
	SlaveName string `json:"slaveName"`
	MbxProtocols uint32 `json:"mbxProtocols"`
	MbxStandard *EthercatMailboxInfoT `json:"mbxStandard"`
	MbxBootstrap *EthercatMailboxInfoT `json:"mbxBootstrap"`
	ProcessDataIn []*EthercatMemoryInfoT `json:"processDataIn"`
	ProcessDataOut []*EthercatMemoryInfoT `json:"processDataOut"`
	NumProcessVarsIn uint16 `json:"numProcessVarsIn"`
	NumProcessVarsOut uint16 `json:"numProcessVarsOut"`
	PortDescriptor byte `json:"portDescriptor"`
	Reserved01 []byte `json:"reserved01"`
	WkcStateDiagOffsIn []uint16 `json:"wkcStateDiagOffsIn"`
	WkcStateDiagOffsOut []uint16 `json:"wkcStateDiagOffsOut"`
	Reserved02 []uint32 `json:"reserved02"`
	IsPresent bool `json:"isPresent"`
	IsHcGroupPresent bool `json:"isHcGroupPresent"`
	DcSupport bool `json:"dcSupport"`
	IsDisabled bool `json:"isDisabled"`
	IsDisconnected bool `json:"isDisconnected"`
	IsExtended bool `json:"isExtended"`
	IsRefClock bool `json:"isRefClock"`
	IsPotentialRefClock bool `json:"isPotentialRefClock"`
	DcCycleTime0 uint32 `json:"dcCycleTime0"`
	DcCycleTime1 uint32 `json:"dcCycleTime1"`
	DcShiftTime int32 `json:"dcShiftTime"`
	MasterSyncUnitIn []uint16 `json:"masterSyncUnitIn"`
	MasterSyncUnitOut []uint16 `json:"masterSyncUnitOut"`
}

func (t *SlaveConfigInfoResponseT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	slaveNameOffset := flatbuffers.UOffsetT(0)
	if t.SlaveName != "" {
		slaveNameOffset = builder.CreateString(t.SlaveName)
	}
	processDataInOffset := flatbuffers.UOffsetT(0)
	if t.ProcessDataIn != nil {
		processDataInLength := len(t.ProcessDataIn)
		SlaveConfigInfoResponseStartProcessDataInVector(builder, processDataInLength)
		for j := processDataInLength - 1; j >= 0; j-- {
			t.ProcessDataIn[j].Pack(builder)
		}
		processDataInOffset = builder.EndVector(processDataInLength)
	}
	processDataOutOffset := flatbuffers.UOffsetT(0)
	if t.ProcessDataOut != nil {
		processDataOutLength := len(t.ProcessDataOut)
		SlaveConfigInfoResponseStartProcessDataOutVector(builder, processDataOutLength)
		for j := processDataOutLength - 1; j >= 0; j-- {
			t.ProcessDataOut[j].Pack(builder)
		}
		processDataOutOffset = builder.EndVector(processDataOutLength)
	}
	reserved01Offset := flatbuffers.UOffsetT(0)
	if t.Reserved01 != nil {
		reserved01Offset = builder.CreateByteString(t.Reserved01)
	}
	wkcStateDiagOffsInOffset := flatbuffers.UOffsetT(0)
	if t.WkcStateDiagOffsIn != nil {
		wkcStateDiagOffsInLength := len(t.WkcStateDiagOffsIn)
		SlaveConfigInfoResponseStartWkcStateDiagOffsInVector(builder, wkcStateDiagOffsInLength)
		for j := wkcStateDiagOffsInLength - 1; j >= 0; j-- {
			builder.PrependUint16(t.WkcStateDiagOffsIn[j])
		}
		wkcStateDiagOffsInOffset = builder.EndVector(wkcStateDiagOffsInLength)
	}
	wkcStateDiagOffsOutOffset := flatbuffers.UOffsetT(0)
	if t.WkcStateDiagOffsOut != nil {
		wkcStateDiagOffsOutLength := len(t.WkcStateDiagOffsOut)
		SlaveConfigInfoResponseStartWkcStateDiagOffsOutVector(builder, wkcStateDiagOffsOutLength)
		for j := wkcStateDiagOffsOutLength - 1; j >= 0; j-- {
			builder.PrependUint16(t.WkcStateDiagOffsOut[j])
		}
		wkcStateDiagOffsOutOffset = builder.EndVector(wkcStateDiagOffsOutLength)
	}
	reserved02Offset := flatbuffers.UOffsetT(0)
	if t.Reserved02 != nil {
		reserved02Length := len(t.Reserved02)
		SlaveConfigInfoResponseStartReserved02Vector(builder, reserved02Length)
		for j := reserved02Length - 1; j >= 0; j-- {
			builder.PrependUint32(t.Reserved02[j])
		}
		reserved02Offset = builder.EndVector(reserved02Length)
	}
	masterSyncUnitInOffset := flatbuffers.UOffsetT(0)
	if t.MasterSyncUnitIn != nil {
		masterSyncUnitInLength := len(t.MasterSyncUnitIn)
		SlaveConfigInfoResponseStartMasterSyncUnitInVector(builder, masterSyncUnitInLength)
		for j := masterSyncUnitInLength - 1; j >= 0; j-- {
			builder.PrependUint16(t.MasterSyncUnitIn[j])
		}
		masterSyncUnitInOffset = builder.EndVector(masterSyncUnitInLength)
	}
	masterSyncUnitOutOffset := flatbuffers.UOffsetT(0)
	if t.MasterSyncUnitOut != nil {
		masterSyncUnitOutLength := len(t.MasterSyncUnitOut)
		SlaveConfigInfoResponseStartMasterSyncUnitOutVector(builder, masterSyncUnitOutLength)
		for j := masterSyncUnitOutLength - 1; j >= 0; j-- {
			builder.PrependUint16(t.MasterSyncUnitOut[j])
		}
		masterSyncUnitOutOffset = builder.EndVector(masterSyncUnitOutLength)
	}
	SlaveConfigInfoResponseStart(builder)
	SlaveConfigInfoResponseAddAutoIncAddr(builder, t.AutoIncAddr)
	SlaveConfigInfoResponseAddEthercatAddr(builder, t.EthercatAddr)
	SlaveConfigInfoResponseAddIdentifyAdo(builder, t.IdentifyAdo)
	SlaveConfigInfoResponseAddIdentifyValue(builder, t.IdentifyValue)
	SlaveConfigInfoResponseAddSlaveHandle(builder, t.SlaveHandle)
	SlaveConfigInfoResponseAddHcGroupIdx(builder, t.HcGroupIdx)
	SlaveConfigInfoResponseAddPreviousEthercatAddr(builder, t.PreviousEthercatAddr)
	SlaveConfigInfoResponseAddPreviousPort(builder, t.PreviousPort)
	slaveIdentityOffset := t.SlaveIdentity.Pack(builder)
	SlaveConfigInfoResponseAddSlaveIdentity(builder, slaveIdentityOffset)
	SlaveConfigInfoResponseAddSlaveName(builder, slaveNameOffset)
	SlaveConfigInfoResponseAddMbxProtocols(builder, t.MbxProtocols)
	mbxStandardOffset := t.MbxStandard.Pack(builder)
	SlaveConfigInfoResponseAddMbxStandard(builder, mbxStandardOffset)
	mbxBootstrapOffset := t.MbxBootstrap.Pack(builder)
	SlaveConfigInfoResponseAddMbxBootstrap(builder, mbxBootstrapOffset)
	SlaveConfigInfoResponseAddProcessDataIn(builder, processDataInOffset)
	SlaveConfigInfoResponseAddProcessDataOut(builder, processDataOutOffset)
	SlaveConfigInfoResponseAddNumProcessVarsIn(builder, t.NumProcessVarsIn)
	SlaveConfigInfoResponseAddNumProcessVarsOut(builder, t.NumProcessVarsOut)
	SlaveConfigInfoResponseAddPortDescriptor(builder, t.PortDescriptor)
	SlaveConfigInfoResponseAddReserved01(builder, reserved01Offset)
	SlaveConfigInfoResponseAddWkcStateDiagOffsIn(builder, wkcStateDiagOffsInOffset)
	SlaveConfigInfoResponseAddWkcStateDiagOffsOut(builder, wkcStateDiagOffsOutOffset)
	SlaveConfigInfoResponseAddReserved02(builder, reserved02Offset)
	SlaveConfigInfoResponseAddIsPresent(builder, t.IsPresent)
	SlaveConfigInfoResponseAddIsHcGroupPresent(builder, t.IsHcGroupPresent)
	SlaveConfigInfoResponseAddDcSupport(builder, t.DcSupport)
	SlaveConfigInfoResponseAddIsDisabled(builder, t.IsDisabled)
	SlaveConfigInfoResponseAddIsDisconnected(builder, t.IsDisconnected)
	SlaveConfigInfoResponseAddIsExtended(builder, t.IsExtended)
	SlaveConfigInfoResponseAddIsRefClock(builder, t.IsRefClock)
	SlaveConfigInfoResponseAddIsPotentialRefClock(builder, t.IsPotentialRefClock)
	SlaveConfigInfoResponseAddDcCycleTime0(builder, t.DcCycleTime0)
	SlaveConfigInfoResponseAddDcCycleTime1(builder, t.DcCycleTime1)
	SlaveConfigInfoResponseAddDcShiftTime(builder, t.DcShiftTime)
	SlaveConfigInfoResponseAddMasterSyncUnitIn(builder, masterSyncUnitInOffset)
	SlaveConfigInfoResponseAddMasterSyncUnitOut(builder, masterSyncUnitOutOffset)
	return SlaveConfigInfoResponseEnd(builder)
}

func (rcv *SlaveConfigInfoResponse) UnPackTo(t *SlaveConfigInfoResponseT) {
	t.AutoIncAddr = rcv.AutoIncAddr()
	t.EthercatAddr = rcv.EthercatAddr()
	t.IdentifyAdo = rcv.IdentifyAdo()
	t.IdentifyValue = rcv.IdentifyValue()
	t.SlaveHandle = rcv.SlaveHandle()
	t.HcGroupIdx = rcv.HcGroupIdx()
	t.PreviousEthercatAddr = rcv.PreviousEthercatAddr()
	t.PreviousPort = rcv.PreviousPort()
	t.SlaveIdentity = rcv.SlaveIdentity(nil).UnPack()
	t.SlaveName = string(rcv.SlaveName())
	t.MbxProtocols = rcv.MbxProtocols()
	t.MbxStandard = rcv.MbxStandard(nil).UnPack()
	t.MbxBootstrap = rcv.MbxBootstrap(nil).UnPack()
	processDataInLength := rcv.ProcessDataInLength()
	t.ProcessDataIn = make([]*EthercatMemoryInfoT, processDataInLength)
	for j := 0; j < processDataInLength; j++ {
		x := EthercatMemoryInfo{}
		rcv.ProcessDataIn(&x, j)
		t.ProcessDataIn[j] = x.UnPack()
	}
	processDataOutLength := rcv.ProcessDataOutLength()
	t.ProcessDataOut = make([]*EthercatMemoryInfoT, processDataOutLength)
	for j := 0; j < processDataOutLength; j++ {
		x := EthercatMemoryInfo{}
		rcv.ProcessDataOut(&x, j)
		t.ProcessDataOut[j] = x.UnPack()
	}
	t.NumProcessVarsIn = rcv.NumProcessVarsIn()
	t.NumProcessVarsOut = rcv.NumProcessVarsOut()
	t.PortDescriptor = rcv.PortDescriptor()
	t.Reserved01 = rcv.Reserved01Bytes()
	wkcStateDiagOffsInLength := rcv.WkcStateDiagOffsInLength()
	t.WkcStateDiagOffsIn = make([]uint16, wkcStateDiagOffsInLength)
	for j := 0; j < wkcStateDiagOffsInLength; j++ {
		t.WkcStateDiagOffsIn[j] = rcv.WkcStateDiagOffsIn(j)
	}
	wkcStateDiagOffsOutLength := rcv.WkcStateDiagOffsOutLength()
	t.WkcStateDiagOffsOut = make([]uint16, wkcStateDiagOffsOutLength)
	for j := 0; j < wkcStateDiagOffsOutLength; j++ {
		t.WkcStateDiagOffsOut[j] = rcv.WkcStateDiagOffsOut(j)
	}
	reserved02Length := rcv.Reserved02Length()
	t.Reserved02 = make([]uint32, reserved02Length)
	for j := 0; j < reserved02Length; j++ {
		t.Reserved02[j] = rcv.Reserved02(j)
	}
	t.IsPresent = rcv.IsPresent()
	t.IsHcGroupPresent = rcv.IsHcGroupPresent()
	t.DcSupport = rcv.DcSupport()
	t.IsDisabled = rcv.IsDisabled()
	t.IsDisconnected = rcv.IsDisconnected()
	t.IsExtended = rcv.IsExtended()
	t.IsRefClock = rcv.IsRefClock()
	t.IsPotentialRefClock = rcv.IsPotentialRefClock()
	t.DcCycleTime0 = rcv.DcCycleTime0()
	t.DcCycleTime1 = rcv.DcCycleTime1()
	t.DcShiftTime = rcv.DcShiftTime()
	masterSyncUnitInLength := rcv.MasterSyncUnitInLength()
	t.MasterSyncUnitIn = make([]uint16, masterSyncUnitInLength)
	for j := 0; j < masterSyncUnitInLength; j++ {
		t.MasterSyncUnitIn[j] = rcv.MasterSyncUnitIn(j)
	}
	masterSyncUnitOutLength := rcv.MasterSyncUnitOutLength()
	t.MasterSyncUnitOut = make([]uint16, masterSyncUnitOutLength)
	for j := 0; j < masterSyncUnitOutLength; j++ {
		t.MasterSyncUnitOut[j] = rcv.MasterSyncUnitOut(j)
	}
}

func (rcv *SlaveConfigInfoResponse) UnPack() *SlaveConfigInfoResponseT {
	if rcv == nil { return nil }
	t := &SlaveConfigInfoResponseT{}
	rcv.UnPackTo(t)
	return t
}

type SlaveConfigInfoResponse struct {
	_tab flatbuffers.Table
}

func GetRootAsSlaveConfigInfoResponse(buf []byte, offset flatbuffers.UOffsetT) *SlaveConfigInfoResponse {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &SlaveConfigInfoResponse{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsSlaveConfigInfoResponse(buf []byte, offset flatbuffers.UOffsetT) *SlaveConfigInfoResponse {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &SlaveConfigInfoResponse{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *SlaveConfigInfoResponse) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *SlaveConfigInfoResponse) Table() flatbuffers.Table {
	return rcv._tab
}

///Auto increment address
func (rcv *SlaveConfigInfoResponse) AutoIncAddr() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Auto increment address
func (rcv *SlaveConfigInfoResponse) MutateAutoIncAddr(n uint16) bool {
	return rcv._tab.MutateUint16Slot(4, n)
}

///EtherCAT address, fixed physical
func (rcv *SlaveConfigInfoResponse) EthercatAddr() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///EtherCAT address, fixed physical
func (rcv *SlaveConfigInfoResponse) MutateEthercatAddr(n uint16) bool {
	return rcv._tab.MutateUint16Slot(6, n)
}

///Address offset (ADO) for identification command
func (rcv *SlaveConfigInfoResponse) IdentifyAdo() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Address offset (ADO) for identification command
func (rcv *SlaveConfigInfoResponse) MutateIdentifyAdo(n uint16) bool {
	return rcv._tab.MutateUint16Slot(8, n)
}

///Identification value to be validated (identifyAdo value)
func (rcv *SlaveConfigInfoResponse) IdentifyValue() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Identification value to be validated (identifyAdo value)
func (rcv *SlaveConfigInfoResponse) MutateIdentifyValue(n uint16) bool {
	return rcv._tab.MutateUint16Slot(10, n)
}

///Internal slave id (internal use)
func (rcv *SlaveConfigInfoResponse) SlaveHandle() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///Internal slave id (internal use)
func (rcv *SlaveConfigInfoResponse) MutateSlaveHandle(n uint32) bool {
	return rcv._tab.MutateUint32Slot(12, n)
}

///Index of the hot connect group (0 = mandatory)
func (rcv *SlaveConfigInfoResponse) HcGroupIdx() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///Index of the hot connect group (0 = mandatory)
func (rcv *SlaveConfigInfoResponse) MutateHcGroupIdx(n uint32) bool {
	return rcv._tab.MutateUint32Slot(14, n)
}

///EtherCAT address of the previous slave
func (rcv *SlaveConfigInfoResponse) PreviousEthercatAddr() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///EtherCAT address of the previous slave
func (rcv *SlaveConfigInfoResponse) MutatePreviousEthercatAddr(n uint16) bool {
	return rcv._tab.MutateUint16Slot(16, n)
}

///Connected port of the previous slave
func (rcv *SlaveConfigInfoResponse) PreviousPort() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Connected port of the previous slave
func (rcv *SlaveConfigInfoResponse) MutatePreviousPort(n uint16) bool {
	return rcv._tab.MutateUint16Slot(18, n)
}

///Slave identity info
func (rcv *SlaveConfigInfoResponse) SlaveIdentity(obj *EthercatIdentityInfo) *EthercatIdentityInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(EthercatIdentityInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

///Slave identity info
///configured device name
func (rcv *SlaveConfigInfoResponse) SlaveName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///configured device name
///Mailbox supported Protocols (config data)
///Bit 0: AoE (ADS over EtherCAT) (ADS: Automation Device Specification)
///Bit 1: EoE (Ethernet over EtherCAT)
///Bit 2: CoE (CAN application protocol over EtherCAT)
///Bit 3: FoE (File access over EtherCAT)
///Bit 4: SoE (Servo drive over EtherCAT)
///Bit 5: VoE (Vendor specific protocol over EtherCAT)
///Bit 6 to 31: Reserved
func (rcv *SlaveConfigInfoResponse) MbxProtocols() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///Mailbox supported Protocols (config data)
///Bit 0: AoE (ADS over EtherCAT) (ADS: Automation Device Specification)
///Bit 1: EoE (Ethernet over EtherCAT)
///Bit 2: CoE (CAN application protocol over EtherCAT)
///Bit 3: FoE (File access over EtherCAT)
///Bit 4: SoE (Servo drive over EtherCAT)
///Bit 5: VoE (Vendor specific protocol over EtherCAT)
///Bit 6 to 31: Reserved
func (rcv *SlaveConfigInfoResponse) MutateMbxProtocols(n uint32) bool {
	return rcv._tab.MutateUint32Slot(24, n)
}

///Mailbox standard size
func (rcv *SlaveConfigInfoResponse) MbxStandard(obj *EthercatMailboxInfo) *EthercatMailboxInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(26))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(EthercatMailboxInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

///Mailbox standard size
///Mailbox bootstrap size
func (rcv *SlaveConfigInfoResponse) MbxBootstrap(obj *EthercatMailboxInfo) *EthercatMailboxInfo {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(28))
	if o != 0 {
		x := o + rcv._tab.Pos
		if obj == nil {
			obj = new(EthercatMailboxInfo)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

///Mailbox bootstrap size
///Process data in size and offset
///Offset and size both in units of bits
func (rcv *SlaveConfigInfoResponse) ProcessDataIn(obj *EthercatMemoryInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 8
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SlaveConfigInfoResponse) ProcessDataInLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(30))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///Process data in size and offset
///Offset and size both in units of bits
///Process data out size and offset
///Offset and size both in units of bits
func (rcv *SlaveConfigInfoResponse) ProcessDataOut(obj *EthercatMemoryInfo, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 8
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *SlaveConfigInfoResponse) ProcessDataOutLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(32))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///Process data out size and offset
///Offset and size both in units of bits
///Number of process input variables 
func (rcv *SlaveConfigInfoResponse) NumProcessVarsIn() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(34))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Number of process input variables 
func (rcv *SlaveConfigInfoResponse) MutateNumProcessVarsIn(n uint16) bool {
	return rcv._tab.MutateUint16Slot(34, n)
}

///Number of process output variables
func (rcv *SlaveConfigInfoResponse) NumProcessVarsOut() uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(36))
	if o != 0 {
		return rcv._tab.GetUint16(o + rcv._tab.Pos)
	}
	return 0
}

///Number of process output variables
func (rcv *SlaveConfigInfoResponse) MutateNumProcessVarsOut(n uint16) bool {
	return rcv._tab.MutateUint16Slot(36, n)
}

///Port descriptor (ESC register 0x0007) (0b10 = EBUS, 0b11 = MII/..) (Port0^Bit0:1, Port1^Bit2:3, Port2^Bit4:5, Port3^Bit6:7)
func (rcv *SlaveConfigInfoResponse) PortDescriptor() byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(38))
	if o != 0 {
		return rcv._tab.GetByte(o + rcv._tab.Pos)
	}
	return 0
}

///Port descriptor (ESC register 0x0007) (0b10 = EBUS, 0b11 = MII/..) (Port0^Bit0:1, Port1^Bit2:3, Port2^Bit4:5, Port3^Bit6:7)
func (rcv *SlaveConfigInfoResponse) MutatePortDescriptor(n byte) bool {
	return rcv._tab.MutateByteSlot(38, n)
}

///Reserved
func (rcv *SlaveConfigInfoResponse) Reserved01(j int) byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetByte(a + flatbuffers.UOffsetT(j*1))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) Reserved01Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) Reserved01Bytes() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

///Reserved
func (rcv *SlaveConfigInfoResponse) MutateReserved01(j int, n byte) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(40))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateByte(a+flatbuffers.UOffsetT(j*1), n)
	}
	return false
}

///(internal - do not use)
func (rcv *SlaveConfigInfoResponse) WkcStateDiagOffsIn(j int) uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) WkcStateDiagOffsInLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///(internal - do not use)
func (rcv *SlaveConfigInfoResponse) MutateWkcStateDiagOffsIn(j int, n uint16) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(42))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

///(internal - do not use)
func (rcv *SlaveConfigInfoResponse) WkcStateDiagOffsOut(j int) uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) WkcStateDiagOffsOutLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///(internal - do not use)
func (rcv *SlaveConfigInfoResponse) MutateWkcStateDiagOffsOut(j int, n uint16) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(44))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

///Reserved
func (rcv *SlaveConfigInfoResponse) Reserved02(j int) uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint32(a + flatbuffers.UOffsetT(j*4))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) Reserved02Length() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///Reserved
func (rcv *SlaveConfigInfoResponse) MutateReserved02(j int, n uint32) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(46))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint32(a+flatbuffers.UOffsetT(j*4), n)
	}
	return false
}

///Slave is present connected and reachable over the bus (online)
func (rcv *SlaveConfigInfoResponse) IsPresent() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(48))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave is present connected and reachable over the bus (online)
func (rcv *SlaveConfigInfoResponse) MutateIsPresent(n bool) bool {
	return rcv._tab.MutateBoolSlot(48, n)
}

///The Hot Connect Group of the slave is present
func (rcv *SlaveConfigInfoResponse) IsHcGroupPresent() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(50))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///The Hot Connect Group of the slave is present
func (rcv *SlaveConfigInfoResponse) MutateIsHcGroupPresent(n bool) bool {
	return rcv._tab.MutateBoolSlot(50, n)
}

///Slave supports DC (Distributed Clock)
func (rcv *SlaveConfigInfoResponse) DcSupport() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(52))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave supports DC (Distributed Clock)
func (rcv *SlaveConfigInfoResponse) MutateDcSupport(n bool) bool {
	return rcv._tab.MutateBoolSlot(52, n)
}

///Slave disabled by API 
func (rcv *SlaveConfigInfoResponse) IsDisabled() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(54))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave disabled by API 
func (rcv *SlaveConfigInfoResponse) MutateIsDisabled(n bool) bool {
	return rcv._tab.MutateBoolSlot(54, n)
}

///Slave disconnected by API
func (rcv *SlaveConfigInfoResponse) IsDisconnected() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(56))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave disconnected by API
func (rcv *SlaveConfigInfoResponse) MutateIsDisconnected(n bool) bool {
	return rcv._tab.MutateBoolSlot(56, n)
}

///Slave generated by config extension API
func (rcv *SlaveConfigInfoResponse) IsExtended() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(58))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave generated by config extension API
func (rcv *SlaveConfigInfoResponse) MutateIsExtended(n bool) bool {
	return rcv._tab.MutateBoolSlot(58, n)
}

///Slave is reference clock
func (rcv *SlaveConfigInfoResponse) IsRefClock() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(60))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave is reference clock
func (rcv *SlaveConfigInfoResponse) MutateIsRefClock(n bool) bool {
	return rcv._tab.MutateBoolSlot(60, n)
}

///Slave can be used as a reference clock
func (rcv *SlaveConfigInfoResponse) IsPotentialRefClock() bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(62))
	if o != 0 {
		return rcv._tab.GetBool(o + rcv._tab.Pos)
	}
	return false
}

///Slave can be used as a reference clock
func (rcv *SlaveConfigInfoResponse) MutateIsPotentialRefClock(n bool) bool {
	return rcv._tab.MutateBoolSlot(62, n)
}

///Cycle time of Sync0 event in unit of ns
func (rcv *SlaveConfigInfoResponse) DcCycleTime0() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(64))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///Cycle time of Sync0 event in unit of ns
func (rcv *SlaveConfigInfoResponse) MutateDcCycleTime0(n uint32) bool {
	return rcv._tab.MutateUint32Slot(64, n)
}

///Calculated value dwDcCycleTime1 (in unit of ns) = Cycle time of Sync1 event - Cycle time of Sync1 event +Shift time of Sync0 event
func (rcv *SlaveConfigInfoResponse) DcCycleTime1() uint32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(66))
	if o != 0 {
		return rcv._tab.GetUint32(o + rcv._tab.Pos)
	}
	return 0
}

///Calculated value dwDcCycleTime1 (in unit of ns) = Cycle time of Sync1 event - Cycle time of Sync1 event +Shift time of Sync0 event
func (rcv *SlaveConfigInfoResponse) MutateDcCycleTime1(n uint32) bool {
	return rcv._tab.MutateUint32Slot(66, n)
}

///Shift time of Sync0 event in unit of ns
func (rcv *SlaveConfigInfoResponse) DcShiftTime() int32 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(68))
	if o != 0 {
		return rcv._tab.GetInt32(o + rcv._tab.Pos)
	}
	return 0
}

///Shift time of Sync0 event in unit of ns
func (rcv *SlaveConfigInfoResponse) MutateDcShiftTime(n int32) bool {
	return rcv._tab.MutateInt32Slot(68, n)
}

///SyncUnits for process data inputs
func (rcv *SlaveConfigInfoResponse) MasterSyncUnitIn(j int) uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) MasterSyncUnitInLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///SyncUnits for process data inputs
func (rcv *SlaveConfigInfoResponse) MutateMasterSyncUnitIn(j int, n uint16) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(70))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

///SyncUnits for process data outputs
func (rcv *SlaveConfigInfoResponse) MasterSyncUnitOut(j int) uint16 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.GetUint16(a + flatbuffers.UOffsetT(j*2))
	}
	return 0
}

func (rcv *SlaveConfigInfoResponse) MasterSyncUnitOutLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

///SyncUnits for process data outputs
func (rcv *SlaveConfigInfoResponse) MutateMasterSyncUnitOut(j int, n uint16) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(72))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.MutateUint16(a+flatbuffers.UOffsetT(j*2), n)
	}
	return false
}

func SlaveConfigInfoResponseStart(builder *flatbuffers.Builder) {
	builder.StartObject(35)
}
func SlaveConfigInfoResponseAddAutoIncAddr(builder *flatbuffers.Builder, autoIncAddr uint16) {
	builder.PrependUint16Slot(0, autoIncAddr, 0)
}
func SlaveConfigInfoResponseAddEthercatAddr(builder *flatbuffers.Builder, ethercatAddr uint16) {
	builder.PrependUint16Slot(1, ethercatAddr, 0)
}
func SlaveConfigInfoResponseAddIdentifyAdo(builder *flatbuffers.Builder, identifyAdo uint16) {
	builder.PrependUint16Slot(2, identifyAdo, 0)
}
func SlaveConfigInfoResponseAddIdentifyValue(builder *flatbuffers.Builder, identifyValue uint16) {
	builder.PrependUint16Slot(3, identifyValue, 0)
}
func SlaveConfigInfoResponseAddSlaveHandle(builder *flatbuffers.Builder, slaveHandle uint32) {
	builder.PrependUint32Slot(4, slaveHandle, 0)
}
func SlaveConfigInfoResponseAddHcGroupIdx(builder *flatbuffers.Builder, hcGroupIdx uint32) {
	builder.PrependUint32Slot(5, hcGroupIdx, 0)
}
func SlaveConfigInfoResponseAddPreviousEthercatAddr(builder *flatbuffers.Builder, previousEthercatAddr uint16) {
	builder.PrependUint16Slot(6, previousEthercatAddr, 0)
}
func SlaveConfigInfoResponseAddPreviousPort(builder *flatbuffers.Builder, previousPort uint16) {
	builder.PrependUint16Slot(7, previousPort, 0)
}
func SlaveConfigInfoResponseAddSlaveIdentity(builder *flatbuffers.Builder, slaveIdentity flatbuffers.UOffsetT) {
	builder.PrependStructSlot(8, flatbuffers.UOffsetT(slaveIdentity), 0)
}
func SlaveConfigInfoResponseAddSlaveName(builder *flatbuffers.Builder, slaveName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(slaveName), 0)
}
func SlaveConfigInfoResponseAddMbxProtocols(builder *flatbuffers.Builder, mbxProtocols uint32) {
	builder.PrependUint32Slot(10, mbxProtocols, 0)
}
func SlaveConfigInfoResponseAddMbxStandard(builder *flatbuffers.Builder, mbxStandard flatbuffers.UOffsetT) {
	builder.PrependStructSlot(11, flatbuffers.UOffsetT(mbxStandard), 0)
}
func SlaveConfigInfoResponseAddMbxBootstrap(builder *flatbuffers.Builder, mbxBootstrap flatbuffers.UOffsetT) {
	builder.PrependStructSlot(12, flatbuffers.UOffsetT(mbxBootstrap), 0)
}
func SlaveConfigInfoResponseAddProcessDataIn(builder *flatbuffers.Builder, processDataIn flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(13, flatbuffers.UOffsetT(processDataIn), 0)
}
func SlaveConfigInfoResponseStartProcessDataInVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 4)
}
func SlaveConfigInfoResponseAddProcessDataOut(builder *flatbuffers.Builder, processDataOut flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(14, flatbuffers.UOffsetT(processDataOut), 0)
}
func SlaveConfigInfoResponseStartProcessDataOutVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(8, numElems, 4)
}
func SlaveConfigInfoResponseAddNumProcessVarsIn(builder *flatbuffers.Builder, numProcessVarsIn uint16) {
	builder.PrependUint16Slot(15, numProcessVarsIn, 0)
}
func SlaveConfigInfoResponseAddNumProcessVarsOut(builder *flatbuffers.Builder, numProcessVarsOut uint16) {
	builder.PrependUint16Slot(16, numProcessVarsOut, 0)
}
func SlaveConfigInfoResponseAddPortDescriptor(builder *flatbuffers.Builder, portDescriptor byte) {
	builder.PrependByteSlot(17, portDescriptor, 0)
}
func SlaveConfigInfoResponseAddReserved01(builder *flatbuffers.Builder, reserved01 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(18, flatbuffers.UOffsetT(reserved01), 0)
}
func SlaveConfigInfoResponseStartReserved01Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(1, numElems, 1)
}
func SlaveConfigInfoResponseAddWkcStateDiagOffsIn(builder *flatbuffers.Builder, wkcStateDiagOffsIn flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(19, flatbuffers.UOffsetT(wkcStateDiagOffsIn), 0)
}
func SlaveConfigInfoResponseStartWkcStateDiagOffsInVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func SlaveConfigInfoResponseAddWkcStateDiagOffsOut(builder *flatbuffers.Builder, wkcStateDiagOffsOut flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(20, flatbuffers.UOffsetT(wkcStateDiagOffsOut), 0)
}
func SlaveConfigInfoResponseStartWkcStateDiagOffsOutVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func SlaveConfigInfoResponseAddReserved02(builder *flatbuffers.Builder, reserved02 flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(21, flatbuffers.UOffsetT(reserved02), 0)
}
func SlaveConfigInfoResponseStartReserved02Vector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func SlaveConfigInfoResponseAddIsPresent(builder *flatbuffers.Builder, isPresent bool) {
	builder.PrependBoolSlot(22, isPresent, false)
}
func SlaveConfigInfoResponseAddIsHcGroupPresent(builder *flatbuffers.Builder, isHcGroupPresent bool) {
	builder.PrependBoolSlot(23, isHcGroupPresent, false)
}
func SlaveConfigInfoResponseAddDcSupport(builder *flatbuffers.Builder, dcSupport bool) {
	builder.PrependBoolSlot(24, dcSupport, false)
}
func SlaveConfigInfoResponseAddIsDisabled(builder *flatbuffers.Builder, isDisabled bool) {
	builder.PrependBoolSlot(25, isDisabled, false)
}
func SlaveConfigInfoResponseAddIsDisconnected(builder *flatbuffers.Builder, isDisconnected bool) {
	builder.PrependBoolSlot(26, isDisconnected, false)
}
func SlaveConfigInfoResponseAddIsExtended(builder *flatbuffers.Builder, isExtended bool) {
	builder.PrependBoolSlot(27, isExtended, false)
}
func SlaveConfigInfoResponseAddIsRefClock(builder *flatbuffers.Builder, isRefClock bool) {
	builder.PrependBoolSlot(28, isRefClock, false)
}
func SlaveConfigInfoResponseAddIsPotentialRefClock(builder *flatbuffers.Builder, isPotentialRefClock bool) {
	builder.PrependBoolSlot(29, isPotentialRefClock, false)
}
func SlaveConfigInfoResponseAddDcCycleTime0(builder *flatbuffers.Builder, dcCycleTime0 uint32) {
	builder.PrependUint32Slot(30, dcCycleTime0, 0)
}
func SlaveConfigInfoResponseAddDcCycleTime1(builder *flatbuffers.Builder, dcCycleTime1 uint32) {
	builder.PrependUint32Slot(31, dcCycleTime1, 0)
}
func SlaveConfigInfoResponseAddDcShiftTime(builder *flatbuffers.Builder, dcShiftTime int32) {
	builder.PrependInt32Slot(32, dcShiftTime, 0)
}
func SlaveConfigInfoResponseAddMasterSyncUnitIn(builder *flatbuffers.Builder, masterSyncUnitIn flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(33, flatbuffers.UOffsetT(masterSyncUnitIn), 0)
}
func SlaveConfigInfoResponseStartMasterSyncUnitInVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func SlaveConfigInfoResponseAddMasterSyncUnitOut(builder *flatbuffers.Builder, masterSyncUnitOut flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(34, flatbuffers.UOffsetT(masterSyncUnitOut), 0)
}
func SlaveConfigInfoResponseStartMasterSyncUnitOutVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(2, numElems, 2)
}
func SlaveConfigInfoResponseEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
