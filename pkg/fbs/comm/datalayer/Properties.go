// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package datalayer

import (
	"strconv"
	flatbuffers "github.com/google/flatbuffers/go"
)

type Properties byte

const (
	PropertiesNONE              Properties = 0
	PropertiesSampling          Properties = 1
	PropertiesQueueing          Properties = 2
	PropertiesDataChangeFilter  Properties = 3
	PropertiesChangeEvents      Properties = 4
	PropertiesCounting          Properties = 5
	PropertiesLosslessRateLimit Properties = 6
	PropertiesLosslessInterval  Properties = 7
)

var EnumNamesProperties = map[Properties]string{
	PropertiesNONE:              "NONE",
	PropertiesSampling:          "Sampling",
	PropertiesQueueing:          "Queueing",
	PropertiesDataChangeFilter:  "DataChangeFilter",
	PropertiesChangeEvents:      "ChangeEvents",
	PropertiesCounting:          "Counting",
	PropertiesLosslessRateLimit: "LosslessRateLimit",
	PropertiesLosslessInterval:  "LosslessInterval",
}

var EnumValuesProperties = map[string]Properties{
	"NONE":              PropertiesNONE,
	"Sampling":          PropertiesSampling,
	"Queueing":          PropertiesQueueing,
	"DataChangeFilter":  PropertiesDataChangeFilter,
	"ChangeEvents":      PropertiesChangeEvents,
	"Counting":          PropertiesCounting,
	"LosslessRateLimit": PropertiesLosslessRateLimit,
	"LosslessInterval":  PropertiesLosslessInterval,
}

func (v Properties) String() string {
	if s, ok := EnumNamesProperties[v]; ok {
		return s
	}
	return "Properties(" + strconv.FormatInt(int64(v), 10) + ")"
}

type PropertiesT struct {
	Type Properties
	Value interface{}
}

func (t *PropertiesT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil {
		return 0
	}
	switch t.Type {
	case PropertiesSampling:
		return t.Value.(*SamplingT).Pack(builder)
	case PropertiesQueueing:
		return t.Value.(*QueueingT).Pack(builder)
	case PropertiesDataChangeFilter:
		return t.Value.(*DataChangeFilterT).Pack(builder)
	case PropertiesChangeEvents:
		return t.Value.(*ChangeEventsT).Pack(builder)
	case PropertiesCounting:
		return t.Value.(*CountingT).Pack(builder)
	case PropertiesLosslessRateLimit:
		return t.Value.(*LosslessRateLimitT).Pack(builder)
	case PropertiesLosslessInterval:
		return t.Value.(*LosslessIntervalT).Pack(builder)
	}
	return 0
}

func (rcv Properties) UnPack(table flatbuffers.Table) *PropertiesT {
	switch rcv {
	case PropertiesSampling:
		var x Sampling
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesSampling, Value: x.UnPack() }
	case PropertiesQueueing:
		var x Queueing
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesQueueing, Value: x.UnPack() }
	case PropertiesDataChangeFilter:
		var x DataChangeFilter
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesDataChangeFilter, Value: x.UnPack() }
	case PropertiesChangeEvents:
		var x ChangeEvents
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesChangeEvents, Value: x.UnPack() }
	case PropertiesCounting:
		var x Counting
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesCounting, Value: x.UnPack() }
	case PropertiesLosslessRateLimit:
		var x LosslessRateLimit
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesLosslessRateLimit, Value: x.UnPack() }
	case PropertiesLosslessInterval:
		var x LosslessInterval
		x.Init(table.Bytes, table.Pos)
		return &PropertiesT{ Type: PropertiesLosslessInterval, Value: x.UnPack() }
	}
	return nil
}
