// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package datalayer

import (
	"bytes"
	flatbuffers "github.com/google/flatbuffers/go"
)

type ScopeT struct {
	Identifier string `json:"identifier"`
	Name string `json:"name"`
	Description string `json:"description"`
	PermissionsR []string `json:"permissionsR"`
	PermissionsRw []string `json:"permissionsRW"`
	PermissionsX []string `json:"permissionsX"`
	PermissionsRwx []string `json:"permissionsRWX"`
}

func (t *ScopeT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	identifierOffset := flatbuffers.UOffsetT(0)
	if t.Identifier != "" {
		identifierOffset = builder.CreateString(t.Identifier)
	}
	nameOffset := flatbuffers.UOffsetT(0)
	if t.Name != "" {
		nameOffset = builder.CreateString(t.Name)
	}
	descriptionOffset := flatbuffers.UOffsetT(0)
	if t.Description != "" {
		descriptionOffset = builder.CreateString(t.Description)
	}
	permissionsROffset := flatbuffers.UOffsetT(0)
	if t.PermissionsR != nil {
		permissionsRLength := len(t.PermissionsR)
		permissionsROffsets := make([]flatbuffers.UOffsetT, permissionsRLength)
		for j := 0; j < permissionsRLength; j++ {
			permissionsROffsets[j] = builder.CreateString(t.PermissionsR[j])
		}
		ScopeStartPermissionsRVector(builder, permissionsRLength)
		for j := permissionsRLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(permissionsROffsets[j])
		}
		permissionsROffset = builder.EndVector(permissionsRLength)
	}
	permissionsRwOffset := flatbuffers.UOffsetT(0)
	if t.PermissionsRw != nil {
		permissionsRwLength := len(t.PermissionsRw)
		permissionsRwOffsets := make([]flatbuffers.UOffsetT, permissionsRwLength)
		for j := 0; j < permissionsRwLength; j++ {
			permissionsRwOffsets[j] = builder.CreateString(t.PermissionsRw[j])
		}
		ScopeStartPermissionsRwVector(builder, permissionsRwLength)
		for j := permissionsRwLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(permissionsRwOffsets[j])
		}
		permissionsRwOffset = builder.EndVector(permissionsRwLength)
	}
	permissionsXOffset := flatbuffers.UOffsetT(0)
	if t.PermissionsX != nil {
		permissionsXLength := len(t.PermissionsX)
		permissionsXOffsets := make([]flatbuffers.UOffsetT, permissionsXLength)
		for j := 0; j < permissionsXLength; j++ {
			permissionsXOffsets[j] = builder.CreateString(t.PermissionsX[j])
		}
		ScopeStartPermissionsXVector(builder, permissionsXLength)
		for j := permissionsXLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(permissionsXOffsets[j])
		}
		permissionsXOffset = builder.EndVector(permissionsXLength)
	}
	permissionsRwxOffset := flatbuffers.UOffsetT(0)
	if t.PermissionsRwx != nil {
		permissionsRwxLength := len(t.PermissionsRwx)
		permissionsRwxOffsets := make([]flatbuffers.UOffsetT, permissionsRwxLength)
		for j := 0; j < permissionsRwxLength; j++ {
			permissionsRwxOffsets[j] = builder.CreateString(t.PermissionsRwx[j])
		}
		ScopeStartPermissionsRwxVector(builder, permissionsRwxLength)
		for j := permissionsRwxLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(permissionsRwxOffsets[j])
		}
		permissionsRwxOffset = builder.EndVector(permissionsRwxLength)
	}
	ScopeStart(builder)
	ScopeAddIdentifier(builder, identifierOffset)
	ScopeAddName(builder, nameOffset)
	ScopeAddDescription(builder, descriptionOffset)
	ScopeAddPermissionsR(builder, permissionsROffset)
	ScopeAddPermissionsRw(builder, permissionsRwOffset)
	ScopeAddPermissionsX(builder, permissionsXOffset)
	ScopeAddPermissionsRwx(builder, permissionsRwxOffset)
	return ScopeEnd(builder)
}

func (rcv *Scope) UnPackTo(t *ScopeT) {
	t.Identifier = string(rcv.Identifier())
	t.Name = string(rcv.Name())
	t.Description = string(rcv.Description())
	permissionsRLength := rcv.PermissionsRLength()
	t.PermissionsR = make([]string, permissionsRLength)
	for j := 0; j < permissionsRLength; j++ {
		t.PermissionsR[j] = string(rcv.PermissionsR(j))
	}
	permissionsRwLength := rcv.PermissionsRwLength()
	t.PermissionsRw = make([]string, permissionsRwLength)
	for j := 0; j < permissionsRwLength; j++ {
		t.PermissionsRw[j] = string(rcv.PermissionsRw(j))
	}
	permissionsXLength := rcv.PermissionsXLength()
	t.PermissionsX = make([]string, permissionsXLength)
	for j := 0; j < permissionsXLength; j++ {
		t.PermissionsX[j] = string(rcv.PermissionsX(j))
	}
	permissionsRwxLength := rcv.PermissionsRwxLength()
	t.PermissionsRwx = make([]string, permissionsRwxLength)
	for j := 0; j < permissionsRwxLength; j++ {
		t.PermissionsRwx[j] = string(rcv.PermissionsRwx(j))
	}
}

func (rcv *Scope) UnPack() *ScopeT {
	if rcv == nil { return nil }
	t := &ScopeT{}
	rcv.UnPackTo(t)
	return t
}

type Scope struct {
	_tab flatbuffers.Table
}

func GetRootAsScope(buf []byte, offset flatbuffers.UOffsetT) *Scope {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Scope{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsScope(buf []byte, offset flatbuffers.UOffsetT) *Scope {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Scope{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Scope) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Scope) Table() flatbuffers.Table {
	return rcv._tab
}

/// Identifier of the Scope
func (rcv *Scope) Identifier() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Identifier of the Scope
func ScopeKeyCompare(o1, o2 flatbuffers.UOffsetT, buf []byte) bool {
	obj1 := &Scope{}
	obj2 := &Scope{}
	obj1.Init(buf, flatbuffers.UOffsetT(len(buf)) - o1)
	obj2.Init(buf, flatbuffers.UOffsetT(len(buf)) - o2)
	return string(obj1.Identifier()) < string(obj2.Identifier())
}

func (rcv *Scope) LookupByKey(key string, vectorLocation flatbuffers.UOffsetT, buf []byte) bool {
	span := flatbuffers.GetUOffsetT(buf[vectorLocation - 4:])
	start := flatbuffers.UOffsetT(0)
	bKey := []byte(key)
	for span != 0 {
		middle := span / 2
		tableOffset := flatbuffers.GetIndirectOffset(buf, vectorLocation+ 4 * (start + middle))
		obj := &Scope{}
		obj.Init(buf, tableOffset)
		comp := bytes.Compare(obj.Identifier(), bKey)
		if comp > 0 {
			span = middle
		} else if comp < 0 {
			middle += 1
			start += middle
			span -= middle
		} else {
			rcv.Init(buf, tableOffset)
			return true
		}
	}
	return false
}

/// Human readable name of the Scope
func (rcv *Scope) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Human readable name of the Scope
/// Description of the Scope
func (rcv *Scope) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// Description of the Scope
/// List of permission string for read operations
func (rcv *Scope) PermissionsR(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Scope) PermissionsRLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// List of permission string for read operations
/// List of permission string for read/write operations
func (rcv *Scope) PermissionsRw(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Scope) PermissionsRwLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// List of permission string for read/write operations
/// List of permission string for execute operations
func (rcv *Scope) PermissionsX(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Scope) PermissionsXLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// List of permission string for execute operations
/// List of permission string for all operations
func (rcv *Scope) PermissionsRwx(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *Scope) PermissionsRwxLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// List of permission string for all operations
func ScopeStart(builder *flatbuffers.Builder) {
	builder.StartObject(7)
}
func ScopeAddIdentifier(builder *flatbuffers.Builder, identifier flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(identifier), 0)
}
func ScopeAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(name), 0)
}
func ScopeAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(description), 0)
}
func ScopeAddPermissionsR(builder *flatbuffers.Builder, permissionsR flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(permissionsR), 0)
}
func ScopeStartPermissionsRVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ScopeAddPermissionsRw(builder *flatbuffers.Builder, permissionsRw flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(permissionsRw), 0)
}
func ScopeStartPermissionsRwVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ScopeAddPermissionsX(builder *flatbuffers.Builder, permissionsX flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(5, flatbuffers.UOffsetT(permissionsX), 0)
}
func ScopeStartPermissionsXVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ScopeAddPermissionsRwx(builder *flatbuffers.Builder, permissionsRwx flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(permissionsRwx), 0)
}
func ScopeStartPermissionsRwxVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func ScopeEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
