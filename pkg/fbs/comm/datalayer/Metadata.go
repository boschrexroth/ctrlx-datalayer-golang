// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package datalayer

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type MetadataT struct {
	NodeClass NodeClass `json:"nodeClass"`
	Operations *AllowedOperationsT `json:"operations"`
	Description string `json:"description"`
	DescriptionUrl string `json:"descriptionUrl"`
	DisplayName string `json:"displayName"`
	DisplayFormat DisplayFormat `json:"displayFormat"`
	Unit string `json:"unit"`
	Extensions []*ExtensionT `json:"extensions"`
	References []*ReferenceT `json:"references"`
	Descriptions []*LocaleTextT `json:"descriptions"`
	DisplayNames []*LocaleTextT `json:"displayNames"`
}

func (t *MetadataT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	operationsOffset := t.Operations.Pack(builder)
	descriptionOffset := flatbuffers.UOffsetT(0)
	if t.Description != "" {
		descriptionOffset = builder.CreateString(t.Description)
	}
	descriptionUrlOffset := flatbuffers.UOffsetT(0)
	if t.DescriptionUrl != "" {
		descriptionUrlOffset = builder.CreateString(t.DescriptionUrl)
	}
	displayNameOffset := flatbuffers.UOffsetT(0)
	if t.DisplayName != "" {
		displayNameOffset = builder.CreateString(t.DisplayName)
	}
	unitOffset := flatbuffers.UOffsetT(0)
	if t.Unit != "" {
		unitOffset = builder.CreateString(t.Unit)
	}
	extensionsOffset := flatbuffers.UOffsetT(0)
	if t.Extensions != nil {
		extensionsLength := len(t.Extensions)
		extensionsOffsets := make([]flatbuffers.UOffsetT, extensionsLength)
		for j := 0; j < extensionsLength; j++ {
			extensionsOffsets[j] = t.Extensions[j].Pack(builder)
		}
		MetadataStartExtensionsVector(builder, extensionsLength)
		for j := extensionsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(extensionsOffsets[j])
		}
		extensionsOffset = builder.EndVector(extensionsLength)
	}
	referencesOffset := flatbuffers.UOffsetT(0)
	if t.References != nil {
		referencesLength := len(t.References)
		referencesOffsets := make([]flatbuffers.UOffsetT, referencesLength)
		for j := 0; j < referencesLength; j++ {
			referencesOffsets[j] = t.References[j].Pack(builder)
		}
		MetadataStartReferencesVector(builder, referencesLength)
		for j := referencesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(referencesOffsets[j])
		}
		referencesOffset = builder.EndVector(referencesLength)
	}
	descriptionsOffset := flatbuffers.UOffsetT(0)
	if t.Descriptions != nil {
		descriptionsLength := len(t.Descriptions)
		descriptionsOffsets := make([]flatbuffers.UOffsetT, descriptionsLength)
		for j := 0; j < descriptionsLength; j++ {
			descriptionsOffsets[j] = t.Descriptions[j].Pack(builder)
		}
		MetadataStartDescriptionsVector(builder, descriptionsLength)
		for j := descriptionsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(descriptionsOffsets[j])
		}
		descriptionsOffset = builder.EndVector(descriptionsLength)
	}
	displayNamesOffset := flatbuffers.UOffsetT(0)
	if t.DisplayNames != nil {
		displayNamesLength := len(t.DisplayNames)
		displayNamesOffsets := make([]flatbuffers.UOffsetT, displayNamesLength)
		for j := 0; j < displayNamesLength; j++ {
			displayNamesOffsets[j] = t.DisplayNames[j].Pack(builder)
		}
		MetadataStartDisplayNamesVector(builder, displayNamesLength)
		for j := displayNamesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(displayNamesOffsets[j])
		}
		displayNamesOffset = builder.EndVector(displayNamesLength)
	}
	MetadataStart(builder)
	MetadataAddNodeClass(builder, t.NodeClass)
	MetadataAddOperations(builder, operationsOffset)
	MetadataAddDescription(builder, descriptionOffset)
	MetadataAddDescriptionUrl(builder, descriptionUrlOffset)
	MetadataAddDisplayName(builder, displayNameOffset)
	MetadataAddDisplayFormat(builder, t.DisplayFormat)
	MetadataAddUnit(builder, unitOffset)
	MetadataAddExtensions(builder, extensionsOffset)
	MetadataAddReferences(builder, referencesOffset)
	MetadataAddDescriptions(builder, descriptionsOffset)
	MetadataAddDisplayNames(builder, displayNamesOffset)
	return MetadataEnd(builder)
}

func (rcv *Metadata) UnPackTo(t *MetadataT) {
	t.NodeClass = rcv.NodeClass()
	t.Operations = rcv.Operations(nil).UnPack()
	t.Description = string(rcv.Description())
	t.DescriptionUrl = string(rcv.DescriptionUrl())
	t.DisplayName = string(rcv.DisplayName())
	t.DisplayFormat = rcv.DisplayFormat()
	t.Unit = string(rcv.Unit())
	extensionsLength := rcv.ExtensionsLength()
	t.Extensions = make([]*ExtensionT, extensionsLength)
	for j := 0; j < extensionsLength; j++ {
		x := Extension{}
		rcv.Extensions(&x, j)
		t.Extensions[j] = x.UnPack()
	}
	referencesLength := rcv.ReferencesLength()
	t.References = make([]*ReferenceT, referencesLength)
	for j := 0; j < referencesLength; j++ {
		x := Reference{}
		rcv.References(&x, j)
		t.References[j] = x.UnPack()
	}
	descriptionsLength := rcv.DescriptionsLength()
	t.Descriptions = make([]*LocaleTextT, descriptionsLength)
	for j := 0; j < descriptionsLength; j++ {
		x := LocaleText{}
		rcv.Descriptions(&x, j)
		t.Descriptions[j] = x.UnPack()
	}
	displayNamesLength := rcv.DisplayNamesLength()
	t.DisplayNames = make([]*LocaleTextT, displayNamesLength)
	for j := 0; j < displayNamesLength; j++ {
		x := LocaleText{}
		rcv.DisplayNames(&x, j)
		t.DisplayNames[j] = x.UnPack()
	}
}

func (rcv *Metadata) UnPack() *MetadataT {
	if rcv == nil { return nil }
	t := &MetadataT{}
	rcv.UnPackTo(t)
	return t
}

type Metadata struct {
	_tab flatbuffers.Table
}

func GetRootAsMetadata(buf []byte, offset flatbuffers.UOffsetT) *Metadata {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &Metadata{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsMetadata(buf []byte, offset flatbuffers.UOffsetT) *Metadata {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &Metadata{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *Metadata) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *Metadata) Table() flatbuffers.Table {
	return rcv._tab
}

func (rcv *Metadata) NodeClass() NodeClass {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return NodeClass(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Metadata) MutateNodeClass(n NodeClass) bool {
	return rcv._tab.MutateInt8Slot(4, int8(n))
}

func (rcv *Metadata) Operations(obj *AllowedOperations) *AllowedOperations {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		x := rcv._tab.Indirect(o + rcv._tab.Pos)
		if obj == nil {
			obj = new(AllowedOperations)
		}
		obj.Init(rcv._tab.Bytes, x)
		return obj
	}
	return nil
}

/// markdown text only
func (rcv *Metadata) Description() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// markdown text only
/// URL to description
func (rcv *Metadata) DescriptionUrl() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// URL to description
func (rcv *Metadata) DisplayName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Metadata) DisplayFormat() DisplayFormat {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return DisplayFormat(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

func (rcv *Metadata) MutateDisplayFormat(n DisplayFormat) bool {
	return rcv._tab.MutateInt8Slot(14, int8(n))
}

func (rcv *Metadata) Unit() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

func (rcv *Metadata) Extensions(obj *Extension, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Metadata) ExtensionsByKey(obj *Extension, key string) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Metadata) ExtensionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Metadata) References(obj *Reference, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Metadata) ReferencesByKey(obj *Reference, key string) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Metadata) ReferencesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Metadata) Descriptions(obj *LocaleText, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Metadata) DescriptionsByKey(obj *LocaleText, key string) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Metadata) DescriptionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(22))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func (rcv *Metadata) DisplayNames(obj *LocaleText, j int) bool {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		x := rcv._tab.Vector(o)
		x += flatbuffers.UOffsetT(j) * 4
		x = rcv._tab.Indirect(x)
		obj.Init(rcv._tab.Bytes, x)
		return true
	}
	return false
}

func (rcv *Metadata) DisplayNamesByKey(obj *LocaleText, key string) bool{
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		x := rcv._tab.Vector(o)
		return obj.LookupByKey(key, x, rcv._tab.Bytes)
	}
	return false
}

func (rcv *Metadata) DisplayNamesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(24))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

func MetadataStart(builder *flatbuffers.Builder) {
	builder.StartObject(11)
}
func MetadataAddNodeClass(builder *flatbuffers.Builder, nodeClass NodeClass) {
	builder.PrependInt8Slot(0, int8(nodeClass), 0)
}
func MetadataAddOperations(builder *flatbuffers.Builder, operations flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(operations), 0)
}
func MetadataAddDescription(builder *flatbuffers.Builder, description flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(description), 0)
}
func MetadataAddDescriptionUrl(builder *flatbuffers.Builder, descriptionUrl flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(3, flatbuffers.UOffsetT(descriptionUrl), 0)
}
func MetadataAddDisplayName(builder *flatbuffers.Builder, displayName flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(4, flatbuffers.UOffsetT(displayName), 0)
}
func MetadataAddDisplayFormat(builder *flatbuffers.Builder, displayFormat DisplayFormat) {
	builder.PrependInt8Slot(5, int8(displayFormat), 0)
}
func MetadataAddUnit(builder *flatbuffers.Builder, unit flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(6, flatbuffers.UOffsetT(unit), 0)
}
func MetadataAddExtensions(builder *flatbuffers.Builder, extensions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(7, flatbuffers.UOffsetT(extensions), 0)
}
func MetadataStartExtensionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetadataAddReferences(builder *flatbuffers.Builder, references flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(8, flatbuffers.UOffsetT(references), 0)
}
func MetadataStartReferencesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetadataAddDescriptions(builder *flatbuffers.Builder, descriptions flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(9, flatbuffers.UOffsetT(descriptions), 0)
}
func MetadataStartDescriptionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetadataAddDisplayNames(builder *flatbuffers.Builder, displayNames flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(10, flatbuffers.UOffsetT(displayNames), 0)
}
func MetadataStartDisplayNamesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func MetadataEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
