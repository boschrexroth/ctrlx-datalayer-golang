// Code generated by the FlatBuffers compiler. DO NOT EDIT.

package datalayer

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

type FlatcArgumentsT struct {
	Name string `json:"name"`
	Addresses []string `json:"addresses"`
	Options []string `json:"options"`
}

func (t *FlatcArgumentsT) Pack(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	if t == nil { return 0 }
	nameOffset := flatbuffers.UOffsetT(0)
	if t.Name != "" {
		nameOffset = builder.CreateString(t.Name)
	}
	addressesOffset := flatbuffers.UOffsetT(0)
	if t.Addresses != nil {
		addressesLength := len(t.Addresses)
		addressesOffsets := make([]flatbuffers.UOffsetT, addressesLength)
		for j := 0; j < addressesLength; j++ {
			addressesOffsets[j] = builder.CreateString(t.Addresses[j])
		}
		FlatcArgumentsStartAddressesVector(builder, addressesLength)
		for j := addressesLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(addressesOffsets[j])
		}
		addressesOffset = builder.EndVector(addressesLength)
	}
	optionsOffset := flatbuffers.UOffsetT(0)
	if t.Options != nil {
		optionsLength := len(t.Options)
		optionsOffsets := make([]flatbuffers.UOffsetT, optionsLength)
		for j := 0; j < optionsLength; j++ {
			optionsOffsets[j] = builder.CreateString(t.Options[j])
		}
		FlatcArgumentsStartOptionsVector(builder, optionsLength)
		for j := optionsLength - 1; j >= 0; j-- {
			builder.PrependUOffsetT(optionsOffsets[j])
		}
		optionsOffset = builder.EndVector(optionsLength)
	}
	FlatcArgumentsStart(builder)
	FlatcArgumentsAddName(builder, nameOffset)
	FlatcArgumentsAddAddresses(builder, addressesOffset)
	FlatcArgumentsAddOptions(builder, optionsOffset)
	return FlatcArgumentsEnd(builder)
}

func (rcv *FlatcArguments) UnPackTo(t *FlatcArgumentsT) {
	t.Name = string(rcv.Name())
	addressesLength := rcv.AddressesLength()
	t.Addresses = make([]string, addressesLength)
	for j := 0; j < addressesLength; j++ {
		t.Addresses[j] = string(rcv.Addresses(j))
	}
	optionsLength := rcv.OptionsLength()
	t.Options = make([]string, optionsLength)
	for j := 0; j < optionsLength; j++ {
		t.Options[j] = string(rcv.Options(j))
	}
}

func (rcv *FlatcArguments) UnPack() *FlatcArgumentsT {
	if rcv == nil { return nil }
	t := &FlatcArgumentsT{}
	rcv.UnPackTo(t)
	return t
}

type FlatcArguments struct {
	_tab flatbuffers.Table
}

func GetRootAsFlatcArguments(buf []byte, offset flatbuffers.UOffsetT) *FlatcArguments {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &FlatcArguments{}
	x.Init(buf, n+offset)
	return x
}

func GetSizePrefixedRootAsFlatcArguments(buf []byte, offset flatbuffers.UOffsetT) *FlatcArguments {
	n := flatbuffers.GetUOffsetT(buf[offset+flatbuffers.SizeUint32:])
	x := &FlatcArguments{}
	x.Init(buf, n+offset+flatbuffers.SizeUint32)
	return x
}

func (rcv *FlatcArguments) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *FlatcArguments) Table() flatbuffers.Table {
	return rcv._tab
}

/// name of the created result
func (rcv *FlatcArguments) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

/// name of the created result
/// datalayer type addresses which should be compiled
func (rcv *FlatcArguments) Addresses(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *FlatcArguments) AddressesLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// datalayer type addresses which should be compiled
/// flatc compiler options
func (rcv *FlatcArguments) Options(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j*4))
	}
	return nil
}

func (rcv *FlatcArguments) OptionsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

/// flatc compiler options
func FlatcArgumentsStart(builder *flatbuffers.Builder) {
	builder.StartObject(3)
}
func FlatcArgumentsAddName(builder *flatbuffers.Builder, name flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(0, flatbuffers.UOffsetT(name), 0)
}
func FlatcArgumentsAddAddresses(builder *flatbuffers.Builder, addresses flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(1, flatbuffers.UOffsetT(addresses), 0)
}
func FlatcArgumentsStartAddressesVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FlatcArgumentsAddOptions(builder *flatbuffers.Builder, options flatbuffers.UOffsetT) {
	builder.PrependUOffsetTSlot(2, flatbuffers.UOffsetT(options), 0)
}
func FlatcArgumentsStartOptionsVector(builder *flatbuffers.Builder, numElems int) flatbuffers.UOffsetT {
	return builder.StartVector(4, numElems, 4)
}
func FlatcArgumentsEnd(builder *flatbuffers.Builder) flatbuffers.UOffsetT {
	return builder.EndObject()
}
