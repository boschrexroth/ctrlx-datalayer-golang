// MIT License
//
// Copyright (c) 2021-2022 Bosch Rexroth AG
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// Code generated by vfsgen; DO NOT EDIT.

package datalayer

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	pathpkg "path"
	"time"
)

// bfbsFS implements statically the virtual filesystem provided to vfsgen.
var bfbsFS = func() http.FileSystem {
	fs := vfsgen۰FS{
		"/": &vfsgen۰DirInfo{
			name:    "/",
			modTime: time.Date(2021, 3, 13, 14, 17, 57, 495595100, time.UTC),
		},
		"/sub_properties.bfbs": &vfsgen۰CompressedFileInfo{
			name:             "sub_properties.bfbs",
			modTime:          time.Date(2024, 7, 19, 12, 39, 58, 0, time.UTC),
			uncompressedSize: 2066,
			//original sub_properties.bfbs as gzip file content
			compressedContent: []byte("\x1F\x8B\x08\x08\x4E\x24\x9A\x66\x00\x03\x73\x75\x62\x5F\x70\x72\x6F\x70\x65\x72\x74\x69\x65\x73\x2E\x62\x66\x62\x73\x00\x75\x58\x3D\x6C\x1C\xC7\x15\x7E\x24\x4F\xE4\xD9\xA2\xA8\xB3\x70\x40\x68\x86\x41\x06\x81\x93\xD0\x80\x48\x33\x41\x0A\x03\x11\x02\x86\x96\x9D\x28\x31\x24\x45\xA4\x0C\x17\x01\xA4\xB9\xDD\x39\xDE\x22\x7B\xBB\xA7\x9D\x5D\x52\x0C\x54\xB8\x70\xA1\x52\x85\x8A\x14\x2E\x59\xB8\x48\x91\x42\xE9\x5C\x04\x41\x8A\x14\x2A\x53\xA4\x70\x91\x52\x30\x52\xD8\x40\x7E\x8C\xE8\xE7\xF2\xBD\xF9\xD9\x9D\x3B\x9E\x08\x0C\x76\x6F\x77\xDE\xDF\xF7\xDE\xFB\xE6\x2D\xD7\x89\x68\xF7\xBD\xDD\xBD\x2E\x09\x6A\x51\x9B\x96\xA9\x43\x5D\x5A\xC5\xD3\x75\x5C\x89\x76\xB0\x2E\x62\x09\x2C\xFE\xDD\x5D\x24\xEC\x22\x7A\x9F\x66\xFF\x2D\x60\xED\xCF\x13\x7D\x88\x6B\xFB\x8C\xDD\xFB\xF0\x1C\xD1\xC9\x32\xD1\x83\x15\xA2\xF2\x2C\xD1\x5F\x5E\x21\x4A\xCF\xE3\xC5\x6B\xB8\xC7\x9E\x39\xDC\xB6\xB0\x3E\xFD\xCF\x78\xCC\xCF\x5A\xB5\xB6\x0B\xF0\x84\x7D\x5A\x82\x57\x64\x3C\xB8\x60\x5F\xCC\x5D\x76\x3E\xB1\xFE\xC7\x78\xB9\xFA\x6F\xC8\xE2\x39\xEB\xF2\x6B\x09\xEB\x04\x37\x03\xAC\x8B\x58\x4F\xF0\xFB\xF7\x58\x03\xAC\x37\xB0\x5E\xC7\x8A\xF2\xE1\x70\x2B\x96\xA5\x4C\xE5\xB1\x2A\xB6\xAE\x17\xF9\x48\x15\x65\xA2\x34\xDE\xC5\x4F\xC7\x63\xDE\xC7\xB6\x17\x83\x18\x6F\x7F\x69\x6C\x9D\x5F\x70\x76\x5E\x63\x3C\x72\xAD\x53\xA5\xF5\x0D\x59\xAA\xF7\x93\x61\x52\xB2\x5F\xE3\xF1\x98\x7D\x44\xE8\x74\xC6\xC9\x7E\xE2\x64\xBD\x8F\xEC\xFF\x3B\x79\x95\x95\x49\x76\x40\x66\x6F\x17\xF1\x2F\x9B\x37\xCB\x2E\xC6\x65\x6A\x30\xF9\xDC\xC9\x93\x93\xE7\x77\xEF\x0C\x64\x76\xA0\xDE\x3D\x54\x59\xC9\x6E\xD3\xFA\xB3\xC6\xEF\x85\xC0\xEF\xD5\xAF\xAC\xEC\xBC\x93\xE5\xF7\x97\x11\xBA\x95\x7F\x2F\x49\x4B\x55\xF0\xBE\x5F\x07\xF2\xF3\x81\xFC\x87\x4E\xFE\x4C\xE0\xFB\xAF\x2A\x55\x29\xE7\xFB\xC3\x40\x6E\x2E\x90\x7B\xE0\xE4\x16\x03\xB9\x3D\x39\x1C\xA5\x4E\xEE\x3E\xE4\xBA\x2E\xC6\x7B\xB8\xF7\xD8\xF0\xEF\xAB\xD7\xAE\xBE\xCB\x7B\x3E\x78\x3E\x1E\xBF\xCD\xB1\x39\xF9\xBF\xA3\x96\x9E\x58\xBD\x4B\x1E\x0B\xF6\x6B\x1B\x0E\x3F\xC2\x8F\xCE\x9C\xCD\xF5\xDB\x0E\xC3\xA9\x3C\x37\x61\xEF\x17\xC9\xC1\x01\xC7\xBD\x82\x5A\x6B\x19\xDF\x19\x79\xA8\xA7\x7D\xC6\x67\x0A\x7F\xEF\xD7\xF7\x58\xEF\x95\xAC\x9F\x17\x43\x21\x7B\x79\x55\x8A\x43\x99\x56\x4A\x44\x46\xA9\x16\x32\x8B\x85\x72\x19\xB9\xFE\xBC\x89\x89\xF5\xEF\x95\xB2\xAC\xF4\x07\xBC\xDF\x24\x8D\xF5\xAE\xA0\x56\xAE\x93\xED\xB7\xE9\xBC\x79\x9B\xDF\x3A\x65\xB3\x1A\x21\x2E\xA0\x58\x9B\xA2\xCF\x02\x5B\x8C\x87\x37\x90\x41\x3F\x5F\xE3\x19\x79\xF5\xFA\x77\x02\xFD\x49\x5F\x58\x37\xC5\xB5\x22\xB8\xDB\x4F\x86\x4A\x97\xC8\x5D\x1D\xE8\x46\xE2\x1C\x4A\x8F\xE4\xB1\x7E\x93\xF5\xED\xBC\x68\x7C\xE8\x4E\xC6\x5B\xCB\x33\xDE\xEB\x2F\xC1\x7B\xBA\x7E\xBC\x7F\xDF\x99\xF4\xCF\x28\x14\x79\xED\x9E\xF5\x08\x01\xFE\x29\xB0\x7F\x76\xD2\x3E\x23\x0D\xFD\x36\x9B\xDE\x2E\xC7\xBD\xED\x6C\x78\x5B\xAF\x4F\x61\xB1\xFF\xD3\xFD\x9B\x7B\x3E\x68\xBC\x7B\x63\xDC\xD8\x58\xAC\x6D\xB0\xD6\x0B\xA6\x83\xDB\xAE\x6E\x38\x1A\xE6\xAC\x8B\x41\xED\xAE\xE3\xC5\xC9\xBF\x6C\xED\xFA\x5E\xE4\xEB\x3D\xAC\x1F\xB9\x3C\x4F\xD5\xAB\x69\xB3\x5D\x35\x90\x87\x49\x5E\x15\x46\xF7\xEA\x29\x9E\x98\xC6\xED\xAF\x81\x8F\xE7\x18\xDB\x44\x47\xB2\x88\xAF\xAA\x23\xE4\xC0\xE8\x58\x0E\x90\xB0\x9C\xD8\x35\x7A\x96\x6B\x1D\x1C\x89\xD7\x3B\xA5\xE7\x5A\x1A\x5B\x3D\x9F\x23\x96\x0D\x17\x2F\xEF\xB9\x74\xD6\xD6\x1E\x9F\x01\x5C\xC8\xDC\x93\x31\x5E\x7C\x8D\x9F\xDF\x3D\x1D\xDB\x5E\xD5\xD3\x51\x91\x8C\xCA\x24\xCF\x02\xFE\x5D\x03\x5E\x6D\xE3\xE1\xA2\xF1\xCA\xFF\x75\xF0\x86\x4C\xEC\x77\xC9\x72\x39\xDB\xED\x7C\x7F\xB2\x56\x7E\xC9\x98\x94\xA8\x36\x91\x64\x62\x98\xA4\x69\x22\xB4\x8A\xF2\x2C\xD6\xA2\xCC\x45\xA1\x36\x0B\x25\x63\xC1\x4E\x70\x7A\x65\x26\x54\x51\xA0\x94\x8E\xA4\xC6\xCB\x48\x25\x87\x2A\x16\x48\xBE\x90\x22\xCB\x63\x75\x97\xFE\x69\xCF\x97\xB6\xC7\xC0\x6C\xBF\x92\x81\x31\xD1\xF7\x26\xB7\xAB\xE6\xEC\x6C\xD3\xAB\x14\xFE\x75\x41\x4F\xEB\xCE\xB5\x05\xBC\xE3\x1E\xBF\x34\x55\x6B\xDF\x60\x5F\x6F\x54\x38\x3E\x8C\x49\x1D\xE0\x01\x8D\x1D\xC4\xBF\x64\xEA\x86\x8C\x05\xFE\x5B\x39\xDF\x72\xB2\x8C\x73\xC1\xA2\xB8\xDE\x40\xBE\xE7\xB1\xF3\x01\xEE\x3F\x72\xF5\xF0\x24\x20\x12\x6F\xEF\xD6\xCB\xB1\x61\xFB\xD5\x08\x29\x10\x29\x1F\x62\x22\xEF\x8B\x51\xD5\x4B\x13\x3D\x10\x68\x5C\x2D\xB9\xE3\x81\x5F\x96\x97\xE2\x40\x95\xA2\x9F\xE6\x40\x27\x16\x47\x49\x39\x10\x99\x3A\xAA\x37\xD1\xFA\x7F\x1B\xBC\xF8\xB0\x72\x5A\x02\xC4\xD6\x50\xB3\x2F\xCF\xEF\x1C\x9E\x3E\xC4\xF5\x63\x17\xC7\xED\x2F\x4E\xC7\x11\x71\x1C\xBF\x51\x6A\x24\x53\xE4\x6B\x76\x30\x21\x98\x62\x53\x94\x83\x44\xBB\xD0\xB5\xA8\x34\x5C\x47\x34\xB1\x2A\x55\x54\x22\xE2\xBE\x12\xDA\x72\x09\xC7\x5D\xE4\x87\x49\xAC\x0A\x4D\x4F\x82\x58\xF8\xAC\xAF\x4D\xD6\xD1\xAC\xB9\x39\xA5\x99\x13\xCE\x18\xBF\xBB\x26\x16\x9A\x6B\xD1\x23\x5C\x4E\xB0\xD2\xA9\xDC\x33\xE7\xB1\x23\x85\x80\x2D\x4C\x01\xFD\x24\x92\xC6\xD7\xC0\xF9\x9E\x79\x70\x53\xC3\x69\xA6\x7C\x14\xAD\x32\xE7\x4B\x9C\xE8\x51\x8E\xA7\xE5\x00\x34\x98\xC6\x93\x85\x43\xCD\x7C\x60\x51\x6E\x9B\x1A\xEA\x04\xF6\xB7\xC9\xF2\x51\xA1\xEE\x54\x49\xC1\xCC\x49\xF4\xB7\xAF\x4D\xAC\xE7\x3C\x27\x25\x31\x99\x79\x70\x92\xD1\xBA\x26\x63\x5F\x62\xFD\x83\x9A\x33\xFD\xF2\x92\x95\xD9\x77\x36\x7E\xC6\xB1\x5D\xE9\xA3\x5A\x44\xD3\xD7\x42\x16\x4A\x1C\x00\xBC\xEC\x22\x80\xEF\xCB\x2A\x75\x47\xA7\x46\x15\xA5\xA9\xE8\x29\x9B\x17\x59\x95\xF9\x10\x50\x44\x32\x4D\x8F\xB7\x68\xC4\xBA\xF6\x11\x68\x29\x7B\xA9\xF2\xFA\x8E\x45\x84\xD6\xF5\x22\x48\xA5\x46\x51\xCA\x38\x4E\x18\x02\x99\x8A\x7C\xE4\x6E\x46\x8D\xFD\xA3\x41\x12\x0D\x50\x2C\x7D\xD8\xCC\x22\x8B\x1E\x90\xAB\x8B\xA4\xE7\x59\x76\x8B\x1C\x06\x3B\x58\x77\x5D\x9F\xCE\x9E\x17\x8F\xCD\xB4\x3C\xAB\xFF\x29\xE8\x7F\xAE\xE9\x55\x87\xCD\xC9\xFF\x0C\xCE\x9D\x70\xD6\xE1\x3E\x26\x22\xA7\xC7\x56\x93\x45\xBC\x65\xCE\x8F\xAE\xC3\x7E\xC9\xE1\xBD\x6C\xD8\xC1\xEB\x6E\x38\xFA\x15\xA7\xEB\x56\x79\x3C\x62\x85\xF7\x60\x6B\x95\x1A\x7E\xFE\xC4\xCD\xDC\x7E\xAE\x9F\x8A\x69\xD6\x28\x4B\x5F\x3C\x63\x7F\x5B\xF4\x18\xF7\x9F\x39\x7F\x19\x9B\x9F\xBB\xFB\x1F\xDB\xFC\xA0\xAB\xFA\x0A\x1D\x54\x98\x06\xCB\xB3\xF4\x58\x24\x18\xF4\xD4\x10\xB5\x8D\x0C\xA1\x45\x53\xA7\x7D\xA2\x5A\x35\x49\x96\xBF\xC6\xFB\x31\xCA\x14\xC7\x22\xDB\x74\x8C\x62\x28\xDA\x57\x06\xA8\x39\x47\xA1\x42\x93\x6B\x65\xDB\xC5\xFD\x0A\xAF\x91\x7D\xCB\x59\x72\xC8\xF3\x34\xB7\xB0\x91\x2D\x0B\x99\x69\x3C\x2F\x4D\x81\x3F\x7A\xDA\xF4\xB2\xC1\x29\x08\xF2\xE4\xE9\x24\x4E\x65\xCB\x5E\xC5\xEC\xDC\xD7\x63\xFB\xE2\x0B\x8B\x0D\xF3\xD5\x47\x53\xFD\xCD\xE7\x93\xB8\x0A\x92\xB4\x85\x1F\xB1\x0C\x03\xD1\xAF\x9B\x1B\xBF\x86\x68\x82\x04\x28\x19\x66\xD2\x5B\xE2\x66\x56\xBF\xB4\x18\xCA\x28\x02\xA4\x9A\xC5\xAC\x86\xC2\xF0\x83\x81\x80\xCF\x27\xC6\x61\xDB\xD4\xEB\x75\x1B\xDF\xBC\xAF\x85\x0B\xC6\x6F\x88\xEC\x4D\xC0\x4D\x0F\x9E\x35\xDF\x26\xBC\xEF\xFE\x82\x9D\x39\x99\x9F\xF8\x2C\xFF\x14\xEB\x9B\x33\x62\x0E\x3F\x35\x1E\xBB\xF3\xC6\xD7\xF4\xE3\x29\xDB\x3C\x5B\x0D\x55\x29\xE3\x7A\xD8\x6E\x6A\xBB\xE5\x6A\x3B\xEC\x89\xE5\x67\x93\xF2\x5C\xDB\xBD\x22\x3F\xD2\x0A\x47\x47\xE9\x35\xAC\xB8\xB9\x80\xBB\xA3\x63\x6C\xB0\xF4\xAC\xEF\x8E\xF6\x8B\xC9\xEF\x03\x9E\x05\x0D\xD5\x38\x55\x0F\x9F\x4F\xE6\xFB\xE3\x79\x7B\xE5\x19\xF4\xDB\xA7\x63\x9F\xF1\xA9\xB4\x86\x6E\x9C\xE4\x7D\xFB\x67\xCF\x30\xF6\x8B\x79\xEB\xF6\x54\x4D\xFC\x82\x2C\x2F\x6E\xC8\x9E\xDE\x48\x25\x42\x93\x23\x6E\x99\xD8\x4E\xB4\x9B\x5C\xF7\xE6\xF6\x4D\xF1\x13\x70\xA4\x8C\x77\xC1\xF6\xEE\x41\x64\xB7\x6E\xD4\x5B\xD0\x78\xF7\x6D\x9C\x67\xFD\x6C\x32\x21\xC2\xFD\x8F\xF7\xEB\x61\xFF\xCF\x35\xBC\xD6\x9A\x9B\x59\xDB\xC1\x67\x9D\x8F\xB1\x35\x33\x46\xCE\xDF\x1F\x58\xE7\x54\x8C\x25\x39\xBE\xBE\x63\xF4\xE0\x5C\xE5\x4E\x3B\x38\xDE\x12\x97\x55\x94\x98\x99\x61\x20\x4B\xDB\xA1\x7A\x90\x57\x38\xBE\x50\xEC\x5A\x71\xE3\x16\x7C\xB2\x61\xC0\x34\x9B\x54\x66\x18\xFA\x0E\x3B\x24\x8A\x2A\x03\xC1\x54\x86\x0C\xD0\x00\xE6\x40\x8C\x42\xE1\x2D\xEB\x59\xA7\xE6\xC8\x66\x66\x6A\x66\x6D\xEE\xFB\x5E\x30\x4B\xFF\x70\x6C\xFB\x97\xFF\xA7\x71\xC9\xE1\xE4\x59\xDC\xC7\xC3\x33\x8C\xD0\xC9\x6F\x15\xF3\x4A\xAF\xEA\xF7\x91\xFF\x8E\xF9\xCF\x44\x5D\x6D\xDE\x4E\xCD\x2D\xC6\xE7\x3D\xC8\x10\x99\x13\x33\x3C\x43\x2D\x93\xDB\x79\x7F\x23\xB0\xC3\xCF\xDE\x7A\x0B\xED\x7F\xAB\x39\xB2\xB6\xFA\x3D\xED\x7D\x61\xFF\x66\xE4\x2B\xF8\x9C\x5E\x0B\xFA\xE3\xF4\x5C\xC5\x56\xF8\xBB\xF8\x77\xCE\x93\x9D\xDD\xF3\x13\x71\x1A\xBE\xD2\xAC\x4D\xD5\x23\xE2\x9F\xFF\x38\x31\x52\xE1\x83\x33\x19\x56\x43\xBB\x8B\x73\xEB\x99\x76\x53\x80\xA5\x0A\x64\x01\x8C\x65\x68\xCB\xF3\x9A\x99\xA7\x7E\xB0\xBD\xBD\x6D\x38\x50\x63\xC0\xCC\x0B\x4B\xC7\x75\xAE\x2C\x82\x75\xAE\x5E\x6D\x53\xC3\x01\xDE\x50\x30\x3C\xD2\xFF\x01\x8F\xBC\x44\xF9\xB8\x12\x00\x00"),
		},
	}
	fs["/"].(*vfsgen۰DirInfo).entries = []os.FileInfo{
		fs["/sub_properties.bfbs"].(os.FileInfo),
	}

	return fs
}()

type vfsgen۰FS map[string]interface{}

func (fs vfsgen۰FS) Open(path string) (http.File, error) {
	path = pathpkg.Clean("/" + path)
	f, ok := fs[path]
	if !ok {
		return nil, &os.PathError{Op: "open", Path: path, Err: os.ErrNotExist}
	}

	switch f := f.(type) {
	case *vfsgen۰CompressedFileInfo:
		gr, err := gzip.NewReader(bytes.NewReader(f.compressedContent))
		if err != nil {
			// This should never happen because we generate the gzip bytes such that they are always valid.
			panic("unexpected error reading own gzip compressed bytes: " + err.Error())
		}
		return &vfsgen۰CompressedFile{
			vfsgen۰CompressedFileInfo: f,
			gr:                        gr,
		}, nil
	case *vfsgen۰DirInfo:
		return &vfsgen۰Dir{
			vfsgen۰DirInfo: f,
		}, nil
	default:
		// This should never happen because we generate only the above types.
		panic(fmt.Sprintf("unexpected type %T", f))
	}
}

// vfsgen۰CompressedFileInfo is a static definition of a gzip compressed file.
type vfsgen۰CompressedFileInfo struct {
	name              string
	modTime           time.Time
	compressedContent []byte
	uncompressedSize  int64
}

func (f *vfsgen۰CompressedFileInfo) Readdir(count int) ([]os.FileInfo, error) {
	return nil, fmt.Errorf("cannot Readdir from file %s", f.name)
}
func (f *vfsgen۰CompressedFileInfo) Stat() (os.FileInfo, error) { return f, nil }

func (f *vfsgen۰CompressedFileInfo) GzipBytes() []byte {
	return f.compressedContent
}

func (f *vfsgen۰CompressedFileInfo) Name() string       { return f.name }
func (f *vfsgen۰CompressedFileInfo) Size() int64        { return f.uncompressedSize }
func (f *vfsgen۰CompressedFileInfo) Mode() os.FileMode  { return 0444 }
func (f *vfsgen۰CompressedFileInfo) ModTime() time.Time { return f.modTime }
func (f *vfsgen۰CompressedFileInfo) IsDir() bool        { return false }
func (f *vfsgen۰CompressedFileInfo) Sys() interface{}   { return nil }

// vfsgen۰CompressedFile is an opened compressedFile instance.
type vfsgen۰CompressedFile struct {
	*vfsgen۰CompressedFileInfo
	gr      *gzip.Reader
	grPos   int64 // Actual gr uncompressed position.
	seekPos int64 // Seek uncompressed position.
}

func (f *vfsgen۰CompressedFile) Read(p []byte) (n int, err error) {
	if f.grPos > f.seekPos {
		// Rewind to beginning.
		err = f.gr.Reset(bytes.NewReader(f.compressedContent))
		if err != nil {
			return 0, err
		}
		f.grPos = 0
	}
	if f.grPos < f.seekPos {
		// Fast-forward.
		_, err = io.CopyN(ioutil.Discard, f.gr, f.seekPos-f.grPos)
		if err != nil {
			return 0, err
		}
		f.grPos = f.seekPos
	}
	n, err = f.gr.Read(p)
	f.grPos += int64(n)
	f.seekPos = f.grPos
	return n, err
}
func (f *vfsgen۰CompressedFile) Seek(offset int64, whence int) (int64, error) {
	switch whence {
	case io.SeekStart:
		f.seekPos = 0 + offset
	case io.SeekCurrent:
		f.seekPos += offset
	case io.SeekEnd:
		f.seekPos = f.uncompressedSize + offset
	default:
		panic(fmt.Errorf("invalid whence value: %v", whence))
	}
	return f.seekPos, nil
}
func (f *vfsgen۰CompressedFile) Close() error {
	return f.gr.Close()
}

// vfsgen۰DirInfo is a static definition of a directory.
type vfsgen۰DirInfo struct {
	name    string
	modTime time.Time
	entries []os.FileInfo
}

func (d *vfsgen۰DirInfo) Read([]byte) (int, error) {
	return 0, fmt.Errorf("cannot Read from directory %s", d.name)
}
func (d *vfsgen۰DirInfo) Close() error               { return nil }
func (d *vfsgen۰DirInfo) Stat() (os.FileInfo, error) { return d, nil }

func (d *vfsgen۰DirInfo) Name() string       { return d.name }
func (d *vfsgen۰DirInfo) Size() int64        { return 0 }
func (d *vfsgen۰DirInfo) Mode() os.FileMode  { return 0755 | os.ModeDir }
func (d *vfsgen۰DirInfo) ModTime() time.Time { return d.modTime }
func (d *vfsgen۰DirInfo) IsDir() bool        { return true }
func (d *vfsgen۰DirInfo) Sys() interface{}   { return nil }

// vfsgen۰Dir is an opened dir instance.
type vfsgen۰Dir struct {
	*vfsgen۰DirInfo
	pos int // Position within entries for Seek and Readdir.
}

func (d *vfsgen۰Dir) Seek(offset int64, whence int) (int64, error) {
	if offset == 0 && whence == io.SeekStart {
		d.pos = 0
		return 0, nil
	}
	return 0, fmt.Errorf("unsupported Seek in directory %s", d.name)
}

func (d *vfsgen۰Dir) Readdir(count int) ([]os.FileInfo, error) {
	if d.pos >= len(d.entries) && count > 0 {
		return nil, io.EOF
	}
	if count <= 0 || count > len(d.entries)-d.pos {
		count = len(d.entries) - d.pos
	}
	e := d.entries[d.pos : d.pos+count]
	d.pos += count
	return e, nil
}
